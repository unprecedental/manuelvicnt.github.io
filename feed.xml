<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="https://manuelvivo.dev/feed.xml" rel="self" type="application/atom+xml" /><link href="https://manuelvivo.dev/" rel="alternate" type="text/html" /><updated>2021-05-21T17:56:31+00:00</updated><id>https://manuelvivo.dev/feed.xml</id><title type="html">Manuel Vivo .dev</title><subtitle>A place where you can learn about Android development</subtitle><entry><title type="html">Things to know about Flow’s shareIn and stateIn operators</title><link href="https://manuelvivo.dev/sharein-statein" rel="alternate" type="text/html" title="Things to know about Flow’s shareIn and stateIn operators" /><published>2021-05-07T00:00:00+00:00</published><updated>2021-05-07T00:00:00+00:00</updated><id>https://manuelvivo.dev/sharein-statein</id><content type="html" xml:base="https://manuelvivo.dev/sharein-statein">&lt;p&gt;Become familiar with the &lt;code class=&quot;highlighter-rouge&quot;&gt;shareIn&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;stateIn&lt;/code&gt; operators by example.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/share-in.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Flow.shareIn&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/state-in.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Flow.stateIn&lt;/code&gt;&lt;/a&gt; operators convert cold flows into hot flows: they can multicast the information that comes from a cold upstream flow to multiple collectors. They’re often used to improve performance, add a buffer when collectors are not present, or even as a caching mechanism.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Cold flows&lt;/strong&gt; are created on-demand and emit data when they’re being observed. &lt;strong&gt;Hot flows&lt;/strong&gt; are always active and can emit data regardless of whether or not they’re being observed.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In this blog post, you’ll become familiar with the &lt;code class=&quot;highlighter-rouge&quot;&gt;shareIn&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;stateIn&lt;/code&gt; operators by example. You’ll learn how to configure them to perform certain use cases and avoid common pitfalls you might encounter.&lt;/p&gt;

&lt;h2 id=&quot;the-underlying-flow-producer&quot;&gt;The underlying flow producer&lt;/h2&gt;

&lt;p&gt;Continuing with the example from my &lt;a href=&quot;https://manuelvivo.dev/coroutines-addrepeatingjob&quot;&gt;previous blog post&lt;/a&gt;, the underlying flow producer that we’re using emits location updates. It’s a &lt;em&gt;cold&lt;/em&gt; flow, as it’s implemented using a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/callback-flow.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;callbackFlow&lt;/code&gt;&lt;/a&gt;. Every new collector will trigger the flow producer block, and a new callback will be added to the &lt;code class=&quot;highlighter-rouge&quot;&gt;FusedLocationProviderClient&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocationDataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;locationClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FusedLocationProviderClient&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;locationsSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Flow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;callbackFlow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;callback&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;: &lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;LocationCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onLocationResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocationResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;offer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lastLocation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;requestLocationUpdates&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;createLocationRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Looper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getMainLooper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;addOnFailureListener&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;nf&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// in case of exception, close the Flow&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// clean up when Flow collection ends&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;awaitClose&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;removeLocationUpdates&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Let’s see how we can use the &lt;code class=&quot;highlighter-rouge&quot;&gt;shareIn&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;stateIn&lt;/code&gt; operators to optimize the &lt;code class=&quot;highlighter-rouge&quot;&gt;locationsSource&lt;/code&gt; flow for different use cases.&lt;/p&gt;

&lt;h2 id=&quot;sharein-or-statein&quot;&gt;shareIn or stateIn?&lt;/h2&gt;

&lt;p&gt;The first topic we’ll cover is the difference between &lt;code class=&quot;highlighter-rouge&quot;&gt;shareIn&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;stateIn&lt;/code&gt;. The &lt;code class=&quot;highlighter-rouge&quot;&gt;shareIn&lt;/code&gt; operator returns a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-shared-flow/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SharedFlow&lt;/code&gt;&lt;/a&gt; instance whereas &lt;code class=&quot;highlighter-rouge&quot;&gt;stateIn&lt;/code&gt; returns a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/index.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;StateFlow&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note: To learn more about &lt;code class=&quot;highlighter-rouge&quot;&gt;StateFlow&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;SharedFlow&lt;/code&gt;, check out &lt;a href=&quot;https://developer.android.com/kotlin/flow/stateflow-and-sharedflow&quot;&gt;our documentation&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;StateFlow&lt;/code&gt; is a specialized configuration of &lt;code class=&quot;highlighter-rouge&quot;&gt;SharedFlow&lt;/code&gt; optimized for sharing state: the last emitted item is replayed to new collectors, and items are conflated using &lt;a href=&quot;https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/equals.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Any.equals&lt;/code&gt;&lt;/a&gt;. You can read more about this in the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/index.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;StateFlow&lt;/code&gt; documentation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The main difference between these APIs is that the &lt;code class=&quot;highlighter-rouge&quot;&gt;StateFlow&lt;/code&gt; interface allows you to access the last emitted value synchronously by reading its &lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt; property. That’s not the case with &lt;code class=&quot;highlighter-rouge&quot;&gt;SharedFlow&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;improving-performance&quot;&gt;Improving performance&lt;/h2&gt;

&lt;p&gt;These APIs can improve performance by sharing the same instance of the flow to be observed by all collectors instead of creating new instances of the same flow on-demand.&lt;/p&gt;

&lt;p&gt;In the following example, &lt;code class=&quot;highlighter-rouge&quot;&gt;LocationRepository&lt;/code&gt; consumes the &lt;code class=&quot;highlighter-rouge&quot;&gt;locationsSource&lt;/code&gt; flow exposed by the &lt;code class=&quot;highlighter-rouge&quot;&gt;LocationDataSource&lt;/code&gt; and applies the shareIn operator to make everyone interested in the user’s location collect from the same instance of the flow. Only one instance of the &lt;code class=&quot;highlighter-rouge&quot;&gt;locationsSource&lt;/code&gt; flow is created and shared for all collectors:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocationRepository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;locationDataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocationDataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;externalScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineScope&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;locations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Flow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;locationDataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;locationsSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;shareIn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;externalScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;WhileSubscribed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-sharing-started/-while-subscribed.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;WhileSubscribed&lt;/code&gt;&lt;/a&gt; sharing policy is used to cancel the upstream flow when there are no collectors. In this way, we avoid wasting resources when no one is interested in location updates.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Tip for Android apps!&lt;/strong&gt; You can use &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;WhileSubscribed(5000)&lt;/code&gt;&lt;/strong&gt; most of the time to keep the upstream flow active for 5 seconds more after the disappearance of the last collector. That avoids restarting the upstream flow in certain situations such as configuration changes. This tip is especially helpful when upstream flows are expensive to create and when these operators are used in ViewModels.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;buffering-events&quot;&gt;Buffering events&lt;/h2&gt;

&lt;p&gt;For this example, our requirements have changed, and now we’re asked to always listen for location updates and display the last 10 locations on the screen when the app comes from the background:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocationRepository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;locationDataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocationDataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;externalScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineScope&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;locations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Flow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;locationDataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;locationsSource&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;shareIn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;externalScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SharingStarted&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Eagerly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;replay&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We use a &lt;code class=&quot;highlighter-rouge&quot;&gt;replay&lt;/code&gt; value of 10 to keep the last 10 emitted items in memory and re-emit those every time a collector observes the flow. To keep the underlying flow active all the time and emitting location updates, use the &lt;code class=&quot;highlighter-rouge&quot;&gt;SharingStarted.Eagerly&lt;/code&gt; policy to listen for updates even if there are no collectors.&lt;/p&gt;

&lt;h2 id=&quot;caching-data&quot;&gt;Caching data&lt;/h2&gt;

&lt;p&gt;Our requirements have changed again, and in this case, we don’t need to be &lt;em&gt;always&lt;/em&gt; listening for location updates if the app is in the background. However, we need to cache the last emitted item so that the user always sees some data on the screen, even if stale, while getting the current location. For this case, we can use the &lt;code class=&quot;highlighter-rouge&quot;&gt;stateIn&lt;/code&gt; operator.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocationRepository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;locationDataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocationDataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;externalScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineScope&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;locations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Flow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;locationDataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;locationsSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;stateIn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;externalScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;WhileSubscribed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EmptyLocation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Flow.stateIn&lt;/code&gt; caches and replays the last emitted item to a new collector.&lt;/p&gt;

&lt;h2 id=&quot;watch-out-do-not-create-new-instances-on-each-function-call&quot;&gt;WATCH OUT! Do not create new instances on each function call&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;NEVER&lt;/strong&gt; use &lt;code class=&quot;highlighter-rouge&quot;&gt;shareIn&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;stateIn&lt;/code&gt; to create a new flow that’s returned when calling a function. That’d create a new &lt;code class=&quot;highlighter-rouge&quot;&gt;SharedFlow&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;StateFlow&lt;/code&gt; on each function invocation that will remain in memory until the scope is cancelled or is garbage collected when there are no references to it.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UserRepository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;userLocalDataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UserLocalDataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;externalScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineScope&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// DO NOT USE shareIn or stateIn in a function like this.&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// It creates a new SharedFlow/StateFlow per invocation which is not reused!&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getUser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Flow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;userLocalDataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getUser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;shareIn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;externalScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;WhileSubscribed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;    

    &lt;span class=&quot;c1&quot;&gt;// DO USE shareIn or stateIn in a property&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Flow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;userLocalDataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getUser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;shareIn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;externalScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;WhileSubscribed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;flows-that-require-input&quot;&gt;Flows that require input&lt;/h2&gt;

&lt;p&gt;Flows that require input, like a &lt;code class=&quot;highlighter-rouge&quot;&gt;userId&lt;/code&gt;, cannot be shared easily using &lt;code class=&quot;highlighter-rouge&quot;&gt;shareIn&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;stateIn&lt;/code&gt;. Taking as an example the &lt;a href=&quot;https://github.com/google/iosched&quot;&gt;iosched&lt;/a&gt; open-source project — Google I/O’s Android app — the flow to get user events from &lt;a href=&quot;https://firebase.google.com/docs/firestore/quickstart&quot;&gt;Firestore&lt;/a&gt; is implemented using a &lt;code class=&quot;highlighter-rouge&quot;&gt;callbackFlow&lt;/code&gt;, as you can see &lt;a href=&quot;https://github.com/google/iosched/blob/main/shared/src/main/java/com/google/samples/apps/iosched/shared/data/userevent/FirestoreUserEventDataSource.kt#L107&quot;&gt;in the source code&lt;/a&gt;. As it takes the &lt;code class=&quot;highlighter-rouge&quot;&gt;userId&lt;/code&gt; as a parameter, this flow cannot be reused easily using the &lt;code class=&quot;highlighter-rouge&quot;&gt;shareIn&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;stateIn&lt;/code&gt; operators.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UserRepository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;userEventsDataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FirestoreUserEventDataSource&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// New collectors will register as a new callback in Firestore.&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// As this function depends on a `userId`, the flow cannot be&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// reused by calling shareIn or stateIn in this function.&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// That will cause a new Shared/StateFlow to be created&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// every time the function is called.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getUserEvents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;userId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Flow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;UserEventsResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;userLocalDataSource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getObservableUserEvents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;userId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Optimizing this use case depends on the requirements of your app:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Do you allow receiving events from multiple users at the same time? You might need to create a map of &lt;code class=&quot;highlighter-rouge&quot;&gt;SharedFlow&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;StateFlow&lt;/code&gt; instances, and remove the reference and cancel the upstream flow when the &lt;code class=&quot;highlighter-rouge&quot;&gt;subscriptionCount&lt;/code&gt; reaches zero.&lt;/li&gt;
  &lt;li&gt;If you allow only one user, and all collectors need to update to the new user, you could emit event updates to a common &lt;code class=&quot;highlighter-rouge&quot;&gt;SharedFlow&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;StateFlow&lt;/code&gt; for all collectors and use the common flow as a variable in the class.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;shareIn&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;stateIn&lt;/code&gt; operators can be used with cold flows to improve performance, add a buffer when collectors are not present, or even as a caching mechanism! Use them wisely, and don’t create new instances on each function call — it won’t work as you’d expect!&lt;/p&gt;</content><author><name>Manuel Vivo</name></author><category term="coroutines" /><summary type="html">Become familiar with the shareIn and stateIn operators by example.</summary></entry><entry><title type="html">Hilt is stable! Easier dependency injection on Android</title><link href="https://manuelvivo.dev/hilt-stable" rel="alternate" type="text/html" title="Hilt is stable! Easier dependency injection on Android" /><published>2021-05-04T00:00:00+00:00</published><updated>2021-05-04T00:00:00+00:00</updated><id>https://manuelvivo.dev/hilt-stable</id><content type="html" xml:base="https://manuelvivo.dev/hilt-stable">&lt;p&gt;Hilt, Jetpack’s recommended dependency injection (DI) solution for Android apps, is already stable!&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.android.com/training/dependency-injection/hilt-android&quot;&gt;Hilt&lt;/a&gt;, Jetpack’s recommended &lt;a href=&quot;https://developer.android.com/training/dependency-injection&quot;&gt;dependency injection (DI)&lt;/a&gt; solution for Android apps, is already &lt;strong&gt;stable&lt;/strong&gt;! That means Hilt is fully ready to be used &lt;strong&gt;in production&lt;/strong&gt;. Hilt is simpler than Dagger, enables you to write less boilerplate code, it’s designed for Android and has integration with multiple Jetpack libraries. Several companies have already started taking advantage of Hilt in their apps.&lt;/p&gt;

&lt;p&gt;Hilt was &lt;a href=&quot;https://manuelvivo.dev/di-with-hilt&quot;&gt;first released&lt;/a&gt; as alpha in June 2020 with the mission of defining a &lt;strong&gt;standard way&lt;/strong&gt; to do DI in your Android apps and since then, we’ve received tons of feedback from developers. That not only improved the library, but also, it let us know that we’re working on the right problems.&lt;/p&gt;

&lt;p&gt;Instead of creating dependency graphs by hand, and manually injecting and passing around types where needed, Hilt automatically generates all that code for you at compile time by means of annotations. Hilt can help you &lt;strong&gt;get the most out of DI best practices&lt;/strong&gt; in your app by doing the hard work and &lt;strong&gt;generating all that boilerplate&lt;/strong&gt; you would’ve needed to write otherwise. Also, as it’s fully integrated with Android, Hilt manages the lifecycle of the dependency graphs associated with the Android framework classes automatically for you.&lt;/p&gt;

&lt;p&gt;Let’s see Hilt in action with a quick example! After &lt;a href=&quot;https://developer.android.com/training/dependency-injection/hilt-android#setup&quot;&gt;setting Hilt up&lt;/a&gt;, using it in your project from scratch to inject a ViewModel in an Activity is as easy as adding few annotations to your code as follows:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@HiltAndroidApp&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Setup Hilt in your app&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyApplication&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Application&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Make Hilt aware of this ViewModel&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@HiltViewModel&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LoginViewModel&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@Inject&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;savedStateHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SavedStateHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/* ... Other dependencies Hilt takes care of ... */&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ViewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;


&lt;span class=&quot;c1&quot;&gt;// Make the activity use the right ViewModel factory and&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// inject other dependencies&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@AndroidEntryPoint&lt;/span&gt; 
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LoginActivity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppCompatActivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;loginViewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LoginViewModel&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;viewModels&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Bundle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// loginViewModel is ready to be used&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Apart from what’s mentioned above, why should you use Hilt in your Android app?&lt;/p&gt;

&lt;h2 id=&quot;simpler-than-dagger&quot;&gt;Simpler than Dagger&lt;/h2&gt;

&lt;p&gt;Hilt is built on top of the popular DI library &lt;a href=&quot;https://developer.android.com/training/dependency-injection/dagger-basics&quot;&gt;Dagger&lt;/a&gt; so benefits from the compile time correctness, runtime performance, scalability, and &lt;a href=&quot;https://manuelvivo.dev/dagger-hilt-navigation-android-studio&quot;&gt;Android Studio support&lt;/a&gt; that Dagger provides. Some Dagger annotations, such as @Inject to tell Dagger and Hilt how to provide an instance of a type, are often used in Hilt. But Hilt is simpler than Dagger!&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;“I highly recommend leveraging Dagger for dependency injection in Android applications. However, pure vanilla Dagger can lead to too much room for creativity. When that gets mixed with the complexity of the various lifecycle-aware components that are part of Android development, there’s plenty of room for pitfalls such as memory leaks: for example, accidentally passing in Activity-scoped dependencies into ViewModels. Hilt being opinionated and designed specifically for Android helps you avoid some of the pitfalls when using vanilla Dagger.”&lt;/em&gt; — &lt;a href=&quot;https://twitter.com/mhernand40&quot;&gt;Marcelo Hernandez&lt;/a&gt;, Staff Software Engineer, Tinder&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If you’re already using Dagger in your app and want to migrate to Hilt… fear not! Dagger and Hilt can coexist together, apps can be &lt;a href=&quot;https://dagger.dev/hilt/migration-guide&quot;&gt;migrated&lt;/a&gt; on an as-needed basis.&lt;/p&gt;

&lt;h2 id=&quot;less-boilerplate&quot;&gt;Less boilerplate&lt;/h2&gt;

&lt;p&gt;Hilt is opinionated — this means that it makes decisions for you so that you have less code to write. Hilt defines standard components, or dependency graphs, fully integrated with Android framework classes such as Application, activities, fragments, and views. As well as scope annotations to scope instances of types to those components.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;“Hilt automatically generates the test application and test component via @HiltAndroidTest. We were able to remove between 20% and 40% of boilerplate wire up test code after migrating to Hilt!”&lt;/em&gt; — Jusun Lee, Software Engineer, YouTube&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;“We are only scratching the surface in terms of migrating to Hilt. However, in one of the modules we migrated to Hilt, we saw +78/-182 in terms of lines changed for this library.”&lt;/em&gt; — Marcelo Hernandez, Staff Software Engineer, Tinder&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;designed-for-android&quot;&gt;Designed for Android&lt;/h2&gt;

&lt;p&gt;As opposed to Dagger that is a dependency injection solution for the Java programming language applications, Hilt solely works in Android apps. Some annotations such as &lt;code class=&quot;highlighter-rouge&quot;&gt;@HiltAndroidApp&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;@AndroidEntryPoint&lt;/code&gt;, or &lt;code class=&quot;highlighter-rouge&quot;&gt;@HiltViewModel&lt;/code&gt; are specific to Hilt and define an opinionated way to do DI on Android.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;“Hilt finally offers built-in Android lifecycle aware Dagger components. With Hilt, we can solely focus on Dagger @Modules without having to worry about Components, Subcomponents, the Component provider pattern, and so on.”&lt;/em&gt; — Marcelo Hernandez, Staff Software Engineer, Tinder&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;standardization-of-components-and-bindings&quot;&gt;Standardization of components and bindings&lt;/h2&gt;

&lt;p&gt;For those that know about Dagger, Hilt simplifies the dependency graph by using a &lt;a href=&quot;https://dagger.dev/hilt/monolithic&quot;&gt;monolithic component system&lt;/a&gt; to generate less code at compile time.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;“With Hilt’s monolithic component system, binding definitions are provided once and shared across all classes that use that component. This is a big win as previously, YouTube used a polylithic component system where modules were manually wired-up into custom components and there were many duplicate binding definitions.”&lt;/em&gt; — Jusun Lee, Software Engineer, YouTube&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;“As our Gradle modules separation allows for feature development in isolation, it became easy to be too creative when using Dagger. We’ve found that migrating those modules over to Hilt has actually exposed flaws in which we were inadvertently violating the separation of concerns.”&lt;/em&gt; — Marcelo Hernandez, Staff Software Engineer, Tinder&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;integration-with-other-jetpack-libraries&quot;&gt;Integration with other Jetpack libraries&lt;/h2&gt;

&lt;p&gt;You can use your favourite Jetpack libraries with Hilt out of the box. We provide direct injection support for &lt;strong&gt;ViewModel, WorkManager, Navigation, and Compose&lt;/strong&gt; so far.&lt;/p&gt;

&lt;p&gt;Learn more about Jetpack support in the &lt;a href=&quot;https://developer.android.com/training/dependency-injection/hilt-jetpack&quot;&gt;docs&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;“I really appreciate how Hilt works out of the box with ViewModels and how it eliminates the boilerplate of having to set up a ViewModel.Factory provider with vanilla Dagger.”&lt;/em&gt; — Marcelo Hernandez, Staff Software Engineer, Tinder&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;resources-to-learn-hilt&quot;&gt;Resources to learn Hilt&lt;/h2&gt;

&lt;p&gt;Hilt is Jetpack’s recommended DI solution for Android apps. To learn more about it and start using it in your apps, check out these resources:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Learn about the benefits of dependency injection &lt;a href=&quot;https://developer.android.com/training/dependency-injection&quot;&gt;here&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.android.com/training/dependency-injection/hilt-android&quot;&gt;Documentation&lt;/a&gt; to learn how to use Hilt in your app.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://dagger.dev/hilt/migration-guide&quot;&gt;Migration guide&lt;/a&gt; from Dagger to Hilt.&lt;/li&gt;
  &lt;li&gt;Codelabs to learn Hilt in a step-by-step approach: &lt;a href=&quot;https://codelabs.developers.google.com/codelabs/android-hilt&quot;&gt;Using Hilt in your Android app&lt;/a&gt; and &lt;a href=&quot;https://codelabs.developers.google.com/codelabs/android-dagger-to-hilt&quot;&gt;Migrating from Dagger to Hilt&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;Code samples! Check out Hilt in action in the &lt;a href=&quot;https://github.com/google/iosched&quot;&gt;Google I/O 2020&lt;/a&gt; and &lt;a href=&quot;https://github.com/android/sunflower/&quot;&gt;Sunflower&lt;/a&gt; apps.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.android.com/images/training/dependency-injection/hilt-annotations.pdf&quot;&gt;Cheat sheet&lt;/a&gt; to quickly see &lt;em&gt;what&lt;/em&gt; the different Hilt and Dagger annotations do and &lt;em&gt;how&lt;/em&gt; to use them.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;Huge thanks to &lt;a href=&quot;https://twitter.com/mhernand40&quot;&gt;Marcelo Hernandez&lt;/a&gt; from the Android Tinder team, and Jusun Lee from the Android YouTube team for taking the time to talk about how and why they’re adopting Hilt in their apps.&lt;/p&gt;</content><author><name>Manuel Vivo</name></author><category term="hilt" /><summary type="html">Hilt, Jetpack’s recommended dependency injection (DI) solution for Android apps, is already stable!</summary></entry><entry><title type="html">A safer way to collect flows from Android UIs</title><link href="https://manuelvivo.dev/coroutines-addrepeatingjob" rel="alternate" type="text/html" title="A safer way to collect flows from Android UIs" /><published>2021-03-26T00:00:00+00:00</published><updated>2021-03-26T00:00:00+00:00</updated><id>https://manuelvivo.dev/coroutines-addrepeatingjob</id><content type="html" xml:base="https://manuelvivo.dev/coroutines-addrepeatingjob">&lt;p&gt;Learn how to use the &lt;code class=&quot;highlighter-rouge&quot;&gt;Lifecycle.repeatOnLifecycle&lt;/code&gt; API to safely collect flows from the UI layer in Android.&lt;/p&gt;

&lt;p&gt;In an Android app, &lt;a href=&quot;https://developer.android.com/kotlin/flow&quot;&gt;Kotlin flows&lt;/a&gt; are typically collected from the UI layer to display data updates on the screen. However, you want to collect these flows making sure you’re not doing more work than necessary, wasting resources (both CPU and memory) or leaking data when the view goes to the background.&lt;/p&gt;

&lt;p&gt;In this article, you’ll learn how the &lt;code class=&quot;highlighter-rouge&quot;&gt;Lifecycle.repeatOnLifecycle&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;Flow.flowWithLifecycle&lt;/code&gt; APIs protect you from wasting resources and why they’re a good default to use for flow collection in the UI layer.&lt;/p&gt;

&lt;h2 id=&quot;wasting-resources&quot;&gt;Wasting resources&lt;/h2&gt;

&lt;p&gt;It’s &lt;a href=&quot;https://developer.android.com/kotlin/coroutines/coroutines-best-practices#coroutines-data-layer&quot;&gt;recommended&lt;/a&gt; to expose the &lt;code class=&quot;highlighter-rouge&quot;&gt;Flow&amp;lt;T&amp;gt;&lt;/code&gt; API from lower layers of your app hierarchy regardless of the flow producer implementation details. However, you should also collect them safely.&lt;/p&gt;

&lt;p&gt;A cold flow backed by a &lt;a href=&quot;https://kotlinlang.org/docs/channels.html&quot;&gt;channel&lt;/a&gt; or using operators with buffers such as &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/buffer.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;buffer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/conflate.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;conflate&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-on.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;flowOn&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/share-in.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;shareIn&lt;/code&gt;&lt;/a&gt; is &lt;strong&gt;not safe to collect&lt;/strong&gt; with some of the existing APIs such as &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CoroutineScope.launch&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/launch-in.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Flow&amp;lt;T&amp;gt;.launchIn&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.android.com/reference/kotlin/androidx/lifecycle/LifecycleCoroutineScope&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LifecycleCoroutineScope.launchWhenX&lt;/code&gt;&lt;/a&gt;, unless you manually cancel the &lt;code class=&quot;highlighter-rouge&quot;&gt;Job&lt;/code&gt; that started the coroutine when the activity goes to the background. These APIs will keep the underlying flow producer active while emitting items into the buffer in the background, and thus wasting resources.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note: A &lt;strong&gt;cold&lt;/strong&gt; flow is a type of flow that executes the producer block of code on-demand when a new subscriber collects.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For example, consider this flow that emits Location updates using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/callback-flow.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;callbackFlow&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Implementation of a cold flow backed by a Channel that sends Location updates&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FusedLocationProviderClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;locationFlow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;callbackFlow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;callback&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;: &lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;LocationCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onLocationResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocationResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;offer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lastLocation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;requestLocationUpdates&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;createLocationRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Looper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getMainLooper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;addOnFailureListener&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// in case of exception, close the Flow&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// clean up when Flow collection ends&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;awaitClose&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;removeLocationUpdates&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note: Internally, &lt;code class=&quot;highlighter-rouge&quot;&gt;callbackFlow&lt;/code&gt; uses a &lt;a href=&quot;https://kotlinlang.org/docs/reference/coroutines/channels.html&quot;&gt;channel&lt;/a&gt;, which is conceptually very similar to a blocking &lt;a href=&quot;https://en.wikipedia.org/wiki/Queue_(abstract_data_type)&quot;&gt;queue&lt;/a&gt;, and has a default capacity of 64 elements.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Collecting this flow from the UI layer using any of the aforementioned APIs keeps the flow emitting locations even if the view is not displaying them in the UI! See the example below:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocationActivity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppCompatActivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Bundle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// Collects from the flow when the View is at least STARTED and&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// SUSPENDS the collection when the lifecycle is STOPPED.&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Collecting the flow cancels when the View is DESTROYED.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;lifecycleScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;launchWhenStarted&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;locationProvider&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;locationFlow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;collect&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// New location! Update the map&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Same issue with:&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// - lifecycleScope.launch { /* Collect from locationFlow() here */ }&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// - locationProvider.locationFlow().onEach { /* ... */ }.launchIn(lifecycleScope)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;lifecycleScope.launchWhenStarted&lt;/code&gt; suspends the execution of the coroutine. New locations are not processed, but the &lt;code class=&quot;highlighter-rouge&quot;&gt;callbackFlow&lt;/code&gt; producer keeps sending locations nonetheless. Using the &lt;code class=&quot;highlighter-rouge&quot;&gt;lifecycleScope.launch&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;launchIn&lt;/code&gt; APIs are even more dangerous as the view keeps consuming locations even if it’s in the background! Which could potentially make your app crash.&lt;/p&gt;

&lt;p&gt;To solve this issue with these APIs, you’d need to manually cancel collection when the view goes to the background to cancel the &lt;code class=&quot;highlighter-rouge&quot;&gt;callbackFlow&lt;/code&gt; and avoid the location provider emitting items and wasting resources. For example, you could do something like the following:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocationActivity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppCompatActivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Coroutine listening for Locations&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;locationUpdatesJob&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onStart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;onStart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;locationUpdatesJob&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lifecycleScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;locationProvider&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;locationFlow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;collect&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// New location! Update the map&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onStop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Stop collecting when the View goes to the background&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;locationUpdatesJob&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;onStop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;That’s a good solution, but that’s boilerplate, friends! And if there’s a universal truth about Android developers, it’s that we absolutely detest writing boilerplate code. One of the biggest benefits of not having to write boilerplate code is that with less code, there are fewer chances of making a mistake!&lt;/p&gt;

&lt;h2 id=&quot;lifecyclerepeatonlifecycle&quot;&gt;Lifecycle.repeatOnLifecycle&lt;/h2&gt;

&lt;p&gt;Now that we all are on the same page and know where the problem lies, it’s time to come up with a solution. The solution needs to be 1) simple, 2) friendly or easy to remember/understand, and more importantly 3) safe! It should work for all use cases regardless of the flow implementation details.&lt;/p&gt;

&lt;p&gt;Without further ado, the API you should use is &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Lifecycle.repeatOnLifecycle&lt;/code&gt;&lt;/strong&gt; available in the &lt;a href=&quot;https://developer.android.com/jetpack/androidx/releases/lifecycle&quot;&gt;&lt;em&gt;lifecycle-runtime-ktx&lt;/em&gt;&lt;/a&gt; library.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note: This API is available in the &lt;code class=&quot;highlighter-rouge&quot;&gt;lifecycle:lifecycle-runtime-ktx:2.4.0-alpha01&lt;/code&gt; library or later.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Take a look at the following code:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocationActivity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppCompatActivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Bundle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// Create a new coroutine since repeatOnLifecycle is a suspend function&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;lifecycleScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// The block passed to repeatOnLifecycle is executed when the lifecycle&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// is at least STARTED and is cancelled when the lifecycle is STOPPED.&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// It automatically restarts the block when the lifecycle is STARTED again.&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;lifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;repeatOnLifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Lifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;State&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;STARTED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// Safely collect from locationFlow when the lifecycle is STARTED&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// and stops collection when the lifecycle is STOPPED&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;locationProvider&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;locationFlow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;collect&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;// New location! Update the map&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;repeatOnLifecycle&lt;/code&gt; is a suspend function that takes a &lt;a href=&quot;https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.State&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Lifecycle.State&lt;/code&gt;&lt;/a&gt; as a parameter that is used to &lt;strong&gt;automatically create and launch a new coroutine&lt;/strong&gt; with the block passed to it when the lifecycle reaches that &lt;code class=&quot;highlighter-rouge&quot;&gt;state&lt;/code&gt;, and &lt;strong&gt;cancel the ongoing coroutine&lt;/strong&gt; when the lifecycle falls below the &lt;code class=&quot;highlighter-rouge&quot;&gt;state&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This avoids any boilerplate code since the associated code to cancel the coroutine when it’s no longer needed is automatically done by &lt;code class=&quot;highlighter-rouge&quot;&gt;repeatOnLifecycle&lt;/code&gt;. As you could guess, it’s recommended to call this API in the activity’s &lt;code class=&quot;highlighter-rouge&quot;&gt;onCreate&lt;/code&gt; or fragment’s &lt;code class=&quot;highlighter-rouge&quot;&gt;onViewCreated&lt;/code&gt; methods to avoid unexpected behaviors. See the example below using fragments:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocationFragment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Fragment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onViewCreated&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;View&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Bundle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;viewLifecycleOwner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lifecycleScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;viewLifecycleOwner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;repeatOnLifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Lifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;State&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;STARTED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;locationProvider&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;locationFlow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;collect&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;// New location! Update the map&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Important&lt;/strong&gt;: Fragments should always use the &lt;code class=&quot;highlighter-rouge&quot;&gt;viewLifecycleOwner&lt;/code&gt; to trigger UI updates. However, that’s not the case for &lt;code class=&quot;highlighter-rouge&quot;&gt;DialogFragment&lt;/code&gt;s which might not have a View sometimes. For &lt;code class=&quot;highlighter-rouge&quot;&gt;DialogFragment&lt;/code&gt;s, you can use the &lt;code class=&quot;highlighter-rouge&quot;&gt;lifecycleOwner&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note: This API is available in the &lt;code class=&quot;highlighter-rouge&quot;&gt;lifecycle:lifecycle-runtime-ktx:2.4.0-alpha01&lt;/code&gt; library or later.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;under-the-hood&quot;&gt;Under the hood&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;repeatOnLifecycle&lt;/code&gt; suspends the calling coroutine, re-launches the block when the lifecycle moves in and out of the target &lt;code class=&quot;highlighter-rouge&quot;&gt;state&lt;/code&gt; in a &lt;em&gt;new&lt;/em&gt; coroutine, and &lt;strong&gt;resumes the calling coroutine when the &lt;code class=&quot;highlighter-rouge&quot;&gt;Lifecycle&lt;/code&gt; is destroyed&lt;/strong&gt;. This last point is very important: the coroutine that calls &lt;code class=&quot;highlighter-rouge&quot;&gt;repeatOnLifecycle&lt;/code&gt; won’t resume executing until the lifecycle is destroyed.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocationActivity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppCompatActivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Bundle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// Create a coroutine&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;lifecycleScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            
            &lt;span class=&quot;n&quot;&gt;lifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;repeatOnLifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Lifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;State&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;RESUMED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// Repeat when the lifecycle is RESUMED, cancel when PAUSED&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;// `lifecycle` is DESTROYED when the coroutine resumes. repeatOnLifecycle&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// suspends the execution of the coroutine until the lifecycle is DESTROYED.&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;visual-diagram&quot;&gt;Visual diagram&lt;/h2&gt;

&lt;p&gt;Circling back to the beginning, collecting &lt;code class=&quot;highlighter-rouge&quot;&gt;locationFlow&lt;/code&gt; directly from a coroutine started with &lt;code class=&quot;highlighter-rouge&quot;&gt;lifecycleScope.launch&lt;/code&gt; is dangerous since the collection keeps happening even when the View is in the background.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;repeatOnLifecycle&lt;/code&gt; prevents you from wasting resources and app crashes because it stops and restarts the flow collection when the lifecycle moves in and out of the target state.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;assets/images/2021-03-26-coroutines-addrepeatingjob_2.png&quot; alt=&quot;img&quot; /&gt;
&lt;small&gt;Difference between using and not using the repeatOnLifecycle API.&lt;/small&gt;&lt;/p&gt;

&lt;h2 id=&quot;flowflowwithlifecycle&quot;&gt;Flow.flowWithLifecycle&lt;/h2&gt;

&lt;p&gt;You can also use the &lt;code class=&quot;highlighter-rouge&quot;&gt;Flow.flowWithLifecycle&lt;/code&gt; operator when you have only one flow to collect. This API uses the &lt;code class=&quot;highlighter-rouge&quot;&gt;Lifecycle.repeatOnLifecycle&lt;/code&gt; API under the hood, and emits items and cancels the underlying producer when the &lt;code class=&quot;highlighter-rouge&quot;&gt;Lifecycle&lt;/code&gt; moves in and out of the target state.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocationActivity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppCompatActivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Bundle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;locationProvider&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;locationFlow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;flowWithLifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Lifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;State&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;STARTED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;onEach&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// New location! Update the map&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;launchIn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lifecycleScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note: This API name takes the &lt;code class=&quot;highlighter-rouge&quot;&gt;Flow.flowOn(CoroutineContext)&lt;/code&gt; operator as a precedent since &lt;code class=&quot;highlighter-rouge&quot;&gt;Flow.flowWithLifecycle&lt;/code&gt; changes the &lt;code class=&quot;highlighter-rouge&quot;&gt;CoroutineContext&lt;/code&gt; used to collect the upstream flow while leaving the downstream unaffected. Also, similar to &lt;code class=&quot;highlighter-rouge&quot;&gt;flowOn&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Flow.flowWithLifecycle&lt;/code&gt; adds a buffer in case the consumer doesn’t keep up with the producer. This is due to the fact that its implementation uses a &lt;code class=&quot;highlighter-rouge&quot;&gt;callbackFlow&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;configuring-the-underlying-producer&quot;&gt;Configuring the underlying producer&lt;/h2&gt;

&lt;p&gt;Even if you use these APIs, watch out for hot flows that could waste resources even if they aren’t collected by anyone! There are some valid use cases for them, but do keep that in mind and document it if needed. Having the underlying flow producer active in the background, even if wasting resources, can be beneficial for some use cases: you instantly have fresh data available rather than &lt;em&gt;catching up&lt;/em&gt; and temporarily showing stale data. &lt;strong&gt;Depending on the use case, decide whether the producer needs to be always active or not&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;MutableStateFlow&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;MutableSharedFlow&lt;/code&gt; APIs expose a &lt;code class=&quot;highlighter-rouge&quot;&gt;subscriptionCount&lt;/code&gt; field that you can use to stop the underlying producer when &lt;code class=&quot;highlighter-rouge&quot;&gt;subscriptionCount&lt;/code&gt; is zero. By default, they will keep the producer active as long as the object that holds the flow instance is in memory. There are some valid use cases for this though, for example, a &lt;code class=&quot;highlighter-rouge&quot;&gt;UiState&lt;/code&gt; exposed from the ViewModel to the UI using &lt;code class=&quot;highlighter-rouge&quot;&gt;StateFlow&lt;/code&gt;. That’s ok! This use case demands the ViewModel to always provide the latest UI state to the View.&lt;/p&gt;

&lt;p&gt;Similarly, the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/state-in.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Flow.stateIn&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/share-in.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Flow.shareIn&lt;/code&gt;&lt;/a&gt; operators can be configured with the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-sharing-started/index.html&quot;&gt;sharing started policy&lt;/a&gt; for this. &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-sharing-started/-while-subscribed.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;WhileSubscribed()&lt;/code&gt;&lt;/a&gt; will stop the underlying producer when there are no active observers! On the contrary, &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-sharing-started/-eagerly.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Eagerly&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-sharing-started/-lazily.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Lazily&lt;/code&gt;&lt;/a&gt; will keep the underlying producer active as long as the &lt;code class=&quot;highlighter-rouge&quot;&gt;CoroutineScope&lt;/code&gt; they use is active.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note: The APIs shown in this article are a good default to collect flows from the UI and should be used regardless of the flow implementation detail. These APIs do what they need to do: stop collecting if the UI isn’t visible on screen. It’s up to the flow implementation if it should be always active or not.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;safe-flow-collection-in-jetpack-compose&quot;&gt;Safe Flow collection in Jetpack Compose&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&quot;https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#collectasstate&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Flow.collectAsState&lt;/code&gt;&lt;/a&gt; function is used in Compose to collect flows from composables and represent the values as &lt;a href=&quot;https://developer.android.com/reference/kotlin/androidx/compose/runtime/State&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;State&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; to be able to update Compose UI. Even if Compose doesn’t recompose the UI when the host activity or fragment is in the background, the flow producer is still active and can waste resources. Compose can suffer from the same problem as the View system.&lt;/p&gt;

&lt;p&gt;When collecting flows in Compose, use the &lt;code class=&quot;highlighter-rouge&quot;&gt;Flow.flowWithLifecycle&lt;/code&gt; operator as follows:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Composable&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;LocationScreen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;locationFlow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Flow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Flow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;lifecycleOwner&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocalLifecycleOwner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;locationFlowLifecycleAware&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;remember&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;locationFlow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lifecycleOwner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;locationFlow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;flowWithLifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lifecycleOwner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Lifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;State&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;STARTED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;location&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;locationFlowLifecycleAware&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;collectAsState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Current location, do something with it&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Notice that you &lt;a href=&quot;https://developer.android.com/jetpack/compose/state&quot;&gt;need to &lt;code class=&quot;highlighter-rouge&quot;&gt;remember&lt;/code&gt;&lt;/a&gt; the flow that is aware of the lifecycle with &lt;code class=&quot;highlighter-rouge&quot;&gt;locationFlow&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;lifecycleOwner&lt;/code&gt; as keys to always use the same flow unless one of the keys change.&lt;/p&gt;

&lt;p&gt;In Compose, side effects must be performed in a &lt;a href=&quot;https://developer.android.com/jetpack/compose/lifecycle#state-effect-use-cases&quot;&gt;controlled environment&lt;/a&gt;. For that, use &lt;a href=&quot;https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#launchedeffect_1&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LaunchedEffect&lt;/code&gt;&lt;/a&gt; to create a coroutine that follows the composable’s lifecycle. In its block, you could call the suspend &lt;code class=&quot;highlighter-rouge&quot;&gt;Lifecycle.repeatOnLifecycle&lt;/code&gt; if you need it to re-launch a block of code when the host lifecycle is in a certain &lt;code class=&quot;highlighter-rouge&quot;&gt;State&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;comparison-with-livedata&quot;&gt;Comparison with LiveData&lt;/h2&gt;

&lt;p&gt;You might’ve noticed that this API behaves similarly to &lt;a href=&quot;https://developer.android.com/topic/libraries/architecture/livedata&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LiveData&lt;/code&gt;&lt;/a&gt;, and that’s true! &lt;code class=&quot;highlighter-rouge&quot;&gt;LiveData&lt;/code&gt; is aware of Lifecycle, and its restarting behavior makes it ideal for observing streams of data from the UI. And that’s also the case for the &lt;code class=&quot;highlighter-rouge&quot;&gt;Lifecycle.repeatOnLifecycle&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;Flow.flowWithLifecycle&lt;/code&gt; APIs!&lt;/p&gt;

&lt;p&gt;Collecting flows using these APIs is a natural replacement for &lt;code class=&quot;highlighter-rouge&quot;&gt;LiveData&lt;/code&gt; in &lt;em&gt;Kotlin-only&lt;/em&gt; apps. If you use these APIs for flow collection, &lt;code class=&quot;highlighter-rouge&quot;&gt;LiveData&lt;/code&gt; doesn’t offer any benefits over coroutines and flow. Even more, flows are more flexible since they can be collected from any &lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatcher&lt;/code&gt; and they can be powered with &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/&quot;&gt;all its operators&lt;/a&gt;. As opposed to &lt;code class=&quot;highlighter-rouge&quot;&gt;LiveData&lt;/code&gt;, which has limited operators available and whose values are always observed from the UI thread.&lt;/p&gt;

&lt;h3 id=&quot;stateflow-support-in-data-binding&quot;&gt;StateFlow support in data binding&lt;/h3&gt;

&lt;p&gt;On a different note, one of the reasons you might be using &lt;code class=&quot;highlighter-rouge&quot;&gt;LiveData&lt;/code&gt; is because it’s supported by data binding. Well, so is &lt;a href=&quot;https://developer.android.com/kotlin/flow/stateflow-and-sharedflow&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;StateFlow&lt;/code&gt;&lt;/a&gt;! For more information about &lt;code class=&quot;highlighter-rouge&quot;&gt;StateFlow&lt;/code&gt; support in data binding, &lt;a href=&quot;https://developer.android.com/topic/libraries/data-binding/observability#stateflow&quot;&gt;check out the official documentation&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Use the &lt;code class=&quot;highlighter-rouge&quot;&gt;Lifecycle.repeatOnLifecycle&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;Flow.flowWithLifecycle&lt;/code&gt; APIs to safely collect flows from the UI layer in Android.&lt;/p&gt;</content><author><name>Manuel Vivo</name></author><category term="coroutines" /><summary type="html">Learn how to use the Lifecycle.repeatOnLifecycle API to safely collect flows from the UI layer in Android.</summary></entry><entry><title type="html">Cómo la música ha influenciado mi carrera</title><link href="https://manuelvivo.dev/musas-interview" rel="alternate" type="text/html" title="Cómo la música ha influenciado mi carrera" /><published>2021-02-28T00:00:00+00:00</published><updated>2021-02-28T00:00:00+00:00</updated><id>https://manuelvivo.dev/musas-interview</id><content type="html" xml:base="https://manuelvivo.dev/musas-interview">&lt;p&gt;Entrevista sobre cómo la música, la trompeta 🎺 y Las Musas me han influenciado en mi carrera como ingeniero Android.&lt;/p&gt;

&lt;h2 id=&quot;description&quot;&gt;Description&lt;/h2&gt;

&lt;p&gt;«El ❤️ de Las Musas» es una serie de entrevistas a personas que han estado (y están) relacionadas, de alguna forma, con &lt;a href=&quot;https://www.lasmusas.es&quot;&gt;Las Musas de Guadalupe&lt;/a&gt;. En ellas conoceremos su trayectoria, y cómo sintieron su paso por esta casa.&lt;/p&gt;

&lt;p&gt;Este domingo tenemos con nosotros a Manuel Vicente Vivo, antiguo trompetista de esta familia y, en la actualidad, Android Developer Relations Enginner at Google.&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/omnZx3Q8NZ0&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;</content><author><name>Manuel Vivo</name></author><category term="spanish" /><summary type="html">Entrevista sobre cómo la música, la trompeta 🎺 y Las Musas me han influenciado en mi carrera como ingeniero Android.</summary></entry><entry><title type="html">Bridging the gap between coroutines, JVM threads, and concurrency problems</title><link href="https://manuelvivo.dev/coroutines-and-threads" rel="alternate" type="text/html" title="Bridging the gap between coroutines, JVM threads, and concurrency problems" /><published>2021-02-03T00:00:00+00:00</published><updated>2021-02-03T00:00:00+00:00</updated><id>https://manuelvivo.dev/coroutines-and-threads</id><content type="html" xml:base="https://manuelvivo.dev/coroutines-and-threads">&lt;p&gt;Learn more about how coroutines are executed in the JVM and concurrency problems.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“Coroutines are light-weight threads”&lt;/em&gt;, how many times have you read that? Does that mean anything to you? Probably not. Keep reading to learn more about &lt;strong&gt;how coroutines are actually executed in the JVM&lt;/strong&gt;, how they relate to threads, and the &lt;strong&gt;concurrency issues&lt;/strong&gt; that are inevitable when using the JVM threading model.&lt;/p&gt;

&lt;h2 id=&quot;coroutines-and-jvmthreads&quot;&gt;Coroutines and JVM threads&lt;/h2&gt;

&lt;p&gt;Coroutines aim to simplify code that executes asynchronously. When talking about coroutines in the JVM, &lt;strong&gt;the block of code passed as a lambda to a coroutine builder ultimately gets executed on a specific JVM thread&lt;/strong&gt;. For example, this simple &lt;a href=&quot;https://en.wikipedia.org/wiki/Fibonacci_number&quot;&gt;Fibonacci&lt;/a&gt; calculation:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Coroutine that calculates the 10th Fibonacci number in a background thread&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;someScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;launch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;fibonacci10&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;synchronousFibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;saveFibonacciInMemory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fibonacci10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;synchronousFibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The above &lt;code class=&quot;highlighter-rouge&quot;&gt;async&lt;/code&gt; coroutine’s block of code, that performs a synchronous and blocking fibonacci calculation and saves it to memory, &lt;strong&gt;gets dispatched and scheduled for execution in a thread pool managed by the coroutines library&lt;/strong&gt;, the one configured for &lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatchers.Default&lt;/code&gt;. The code will be executed in a thread of the thread pool at some time in the future depending on the thread pool’s policies.&lt;/p&gt;

&lt;p&gt;Note that the code above executes in one thread because it doesn’t suspend. It’s possible for one coroutine to be executed in different threads if the execution is moved to a different dispatcher, or if the block contains code that may yield/suspend in a dispatcher that uses a thread pool.&lt;/p&gt;

&lt;p&gt;Similarly, without coroutines, you could execute the logic above using threads manually as follows:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Create a thread pool of 4 threads&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;executorService&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Executors&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;newFixedThreadPool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Schedule and execute this code in one of those threads&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;executorService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;execute&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;fibonacci10&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;synchronousFibonacci&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;saveFibonacciInMemory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fibonacci10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;While doing things on your own managing thread pools manually is possible, &lt;strong&gt;coroutines is the recommended solution for asynchronous programming on Android&lt;/strong&gt; due to the built-in cancellation support, easier error handling, &lt;em&gt;structured concurrency&lt;/em&gt; which reduces the likelihood of memory leaks, and its integration with Jetpack libraries.&lt;/p&gt;

&lt;h3 id=&quot;under-thehood&quot;&gt;Under the hood&lt;/h3&gt;

&lt;p&gt;What happens from the moment you create a coroutine until it gets executed on a thread? When you create a coroutine using the standard coroutine builders, you can specify on which &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/CoroutineDispatcher.kt&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CoroutineDispatcher&lt;/code&gt;&lt;/a&gt; to run it on; if not, &lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatchers.Default&lt;/code&gt; is used.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The CoroutineDispatcher is in charge of dispatching the execution of a coroutine to a JVM thread&lt;/strong&gt;. Under the hood, when a &lt;code class=&quot;highlighter-rouge&quot;&gt;CoroutineDispatcher&lt;/code&gt; is used, it intercepts the coroutine using this &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/CoroutineDispatcher.kt#L99&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;interceptContinuation&lt;/code&gt;&lt;/a&gt; method that &lt;strong&gt;wraps the &lt;code class=&quot;highlighter-rouge&quot;&gt;Continuation&lt;/code&gt; (i.e. the coroutine) in a &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/internal/DispatchedContinuation.kt&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DispatchedContinuation&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt;. This is possible because &lt;code class=&quot;highlighter-rouge&quot;&gt;CoroutineDispatcher&lt;/code&gt; implements the &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/stdlib-stubs/src/ContinuationInterceptor.kt&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ContinuationInterceptor&lt;/code&gt;&lt;/a&gt; interface.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;If you read my article about &lt;a href=&quot;https://manuelvivo.dev/suspend-modifier&quot;&gt;how coroutines work under the hood&lt;/a&gt;, you already know that the compiler creates a state machine, and the information of the state machine (e.g. what needs to be executed next) is kept in a &lt;a href=&quot;https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-continuation.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Continuation&lt;/code&gt;&lt;/a&gt; object.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In case a Continuation needs to be executed in a different Dispatcher, the &lt;code class=&quot;highlighter-rouge&quot;&gt;DispatchedContinuation&lt;/code&gt;’s &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/internal/DispatchedContinuation.kt#L178&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;resumeWith&lt;/code&gt;&lt;/a&gt; method is in charge of dispatching the coroutine to the appropriate one!&lt;/p&gt;

&lt;p&gt;Furthermore, a &lt;code class=&quot;highlighter-rouge&quot;&gt;DispatchedContinuation&lt;/code&gt; extends from the &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/internal/DispatchedTask.kt&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DispatchedTask&lt;/code&gt;&lt;/a&gt; abstract class which, in the JVM implementation, is a type that implements the &lt;code class=&quot;highlighter-rouge&quot;&gt;Runnable&lt;/code&gt; interface. Therefore, a &lt;code class=&quot;highlighter-rouge&quot;&gt;DispatchedContinuation&lt;/code&gt; can run on a JVM thread! How cool is that? When a &lt;code class=&quot;highlighter-rouge&quot;&gt;CoroutineDispatcher&lt;/code&gt; is specified, the coroutine is transformed to a &lt;code class=&quot;highlighter-rouge&quot;&gt;DispatchedTask&lt;/code&gt; that is dispatched to be executed on a JVM thread as a &lt;code class=&quot;highlighter-rouge&quot;&gt;Runnable&lt;/code&gt;!&lt;/p&gt;

&lt;p&gt;And now… How does the &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch&lt;/code&gt; method get called when you create a coroutine? When you create a coroutine using the standard coroutine builders, you can specify how the coroutine starts with the &lt;code class=&quot;highlighter-rouge&quot;&gt;start&lt;/code&gt; parameter of type &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/index.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CoroutineStart&lt;/code&gt;&lt;/a&gt;. For example, you can configure it to start only when it’s needed, with &lt;code class=&quot;highlighter-rouge&quot;&gt;CoroutineStart.LAZY&lt;/code&gt;. By default, &lt;code class=&quot;highlighter-rouge&quot;&gt;CoroutineStart.DEFAULT&lt;/code&gt; is used which schedules the coroutine for execution according to its &lt;code class=&quot;highlighter-rouge&quot;&gt;CoroutineDispatcher&lt;/code&gt;. Bingo!&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img width=&quot;1000&quot; src=&quot;assets/images/2021-02-03-coroutines-and-threads_1.png&quot; /&gt;
  &lt;small&gt;Illustration of how the block of code in a coroutine ends up executing in a Thread&lt;/small&gt;
&lt;/p&gt;

&lt;h3 id=&quot;dispatchers-and-threadpools&quot;&gt;Dispatchers and thread pools&lt;/h3&gt;

&lt;p&gt;You can execute coroutines in any of your app thread pools by converting them to a &lt;code class=&quot;highlighter-rouge&quot;&gt;CoroutineDispatcher&lt;/code&gt; using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/java.util.concurrent.-executor/as-coroutine-dispatcher.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Executor.asCoroutineDispatcher()&lt;/code&gt;&lt;/a&gt; extension function. Alternatively, you can use the default &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/src/Dispatchers.kt&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatchers&lt;/code&gt;&lt;/a&gt; that come in the coroutines library.&lt;/p&gt;

&lt;p&gt;You can see how &lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatchers.Default&lt;/code&gt; is initialized in this &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/src/CoroutineContext.kt#L22&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;createDefaultDispatcher&lt;/code&gt;&lt;/a&gt; method. By default, the &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/src/scheduling/Dispatcher.kt&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DefaultScheduler&lt;/code&gt;&lt;/a&gt; is used. If you check out the implementation of &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/src/Dispatchers.kt#L118&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatchers.IO&lt;/code&gt;&lt;/a&gt;, it also uses the &lt;code class=&quot;highlighter-rouge&quot;&gt;DefaultScheduler&lt;/code&gt; and allows at least 64 threads to be created on demand. &lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatchers.Default&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatchers.IO&lt;/code&gt; are implicitly linked together as they use the same thread pool which brings me to the next topic. What’s the runtime overhead of calling &lt;code class=&quot;highlighter-rouge&quot;&gt;withContext&lt;/code&gt; with different Dispatchers?&lt;/p&gt;

&lt;h3 id=&quot;threads-and-withcontext-performance&quot;&gt;Threads and withContext performance&lt;/h3&gt;

&lt;p&gt;In the JVM, if there are more threads created than CPU cores available, switching between threads carries some runtime overhead. &lt;a href=&quot;https://en.wikipedia.org/wiki/Context_switch&quot;&gt;&lt;em&gt;Context switches&lt;/em&gt;&lt;/a&gt; aren’t cheap! The OS needs to save and restore the execution context, and the CPU needs to spend time scheduling threads instead of running actual app work. Apart from that, context switches may happen if a thread is running code that blocks. If that’s the case for threads, is there any performance penalty of using &lt;code class=&quot;highlighter-rouge&quot;&gt;withContext&lt;/code&gt; with different Dispatchers?&lt;/p&gt;

&lt;p&gt;Fortunately, as you could imagine, thread pools manage all of this complexity for us, trying to optimize work to be executed as much as possible (that’s why executing work on a thread pool is better than doing so in threads manually). Coroutines also benefit from this as they’re scheduled in thread pools! On top of that, coroutines don’t block threads, they &lt;em&gt;suspend&lt;/em&gt; their work instead! Even more efficient!&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/jvm/src/scheduling/CoroutineScheduler.kt&quot;&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CoroutineScheduler&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt;, which is the thread pool used in the JVM implementation by default, &lt;strong&gt;distributes dispatched coroutines to worker threads in the most efficient manner&lt;/strong&gt;. As &lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatchers.Default&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatchers.IO&lt;/code&gt; use the same thread pool, switching between them is optimized to avoid thread switches whenever possible. The coroutines library can optimize those calls, stay on the same dispatcher and thread, and follow a fast-path.&lt;/p&gt;

&lt;p&gt;As &lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatchers.Main&lt;/code&gt; is usually a different thread in UI apps, switching between &lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatchers.Default&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatchers.Main&lt;/code&gt; in coroutines doesn’t come with huge performance costs as the coroutine just suspends (i.e. stops executing in one thread), and gets scheduled to be executed in a different thread.&lt;/p&gt;

&lt;h2 id=&quot;concurrency-problems-in-coroutines&quot;&gt;Concurrency problems in coroutines&lt;/h2&gt;

&lt;p&gt;Coroutines DO make asynchronous programming easier due to how simple scheduling work on different threads is. On the other hand, this simplicity can be a double-edged sword: &lt;strong&gt;as coroutines run on the JVM threading model, they cannot simply escape from the concurrency problems that the threading model entails&lt;/strong&gt;. Thus, you have to pay attention to avoid this.&lt;/p&gt;

&lt;p&gt;Over the years, good practices like immutability have mitigated some of the thread-related issues that you can face. However, there are some cases that cannot be avoided with immutability. The mother of all concurrency problems is state management! In particular, accessing &lt;strong&gt;&lt;em&gt;mutable state&lt;/em&gt;&lt;/strong&gt; in a multi-threaded environment.&lt;/p&gt;

&lt;p&gt;The ordering of operations in a multi-threaded app is unpredictable. Apart from compiler optimizations that can reorder operations, threads are not guaranteed to be run in a particular order, and context switches can happen at any time. If the necessary precautions are not taken when accessing mutable state, threads could see stale data, lose updates, or suffer from &lt;a href=&quot;https://en.wikipedia.org/wiki/Race_condition&quot;&gt;&lt;em&gt;race conditions&lt;/em&gt;&lt;/a&gt; among other things.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note that the discussion of mutable state and access order isn’t specific to the JVM. They affect coroutines on other platforms, too.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;An app using coroutines is a multi-threaded app by nature. &lt;strong&gt;Classes that use coroutines and contain mutable state must take precautions to be predictable&lt;/strong&gt;, i.e. ensure the code executed in coroutines see the most up-to-date version of the data. In this way, different threads won’t interfere with one another. Concurrency issues can lead to very subtle bugs very hard to debug in your apps, even &lt;a href=&quot;https://en.wikipedia.org/wiki/Heisenbug&quot;&gt;&lt;em&gt;heisenbugs&lt;/em&gt;&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;These types of classes are not uncommon. Maybe the class needs to keep the information of the logged-in user in memory, or cache some values while the app is alive. Concurrency issues can still happen in coroutines if you’re not careful! A suspend function using &lt;code class=&quot;highlighter-rouge&quot;&gt;withContext(defaultDispatcher)&lt;/code&gt; is not guaranteed to be executed always in the same thread!&lt;/p&gt;

&lt;p&gt;Let’s say we have a class that caches transactions made by users. If the cache is not accessed properly, like for example below, concurrency bugs can happen:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TransactionsRepository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;defaultDispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineDispatcher&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Default&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;transactionsCache&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mutableMapOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;()&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;suspend&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addTransaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// CAREFUL! Access to the cache is not protected.&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Concurrency bugs can happen: threads can see stale data&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// and race conditions may occur.&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;withContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;defaultDispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transactionsCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;oldList&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transactionsCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;newList&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;toMutableList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;newList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;transactionsCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;transactionsCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;listOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Even if we’re talking about Kotlin, the book Java concurrency in practice by Brian Goetz is a great resource to learn more about this topic and the intricacies of concurrency in JVM systems. Alternatively, Jetbrains has documentation about &lt;a href=&quot;https://kotlinlang.org/docs/reference/coroutines/shared-mutable-state-and-concurrency.html&quot;&gt;shared mutable state and concurrency&lt;/a&gt; too.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;protecting-mutablestate&quot;&gt;Protecting mutable state&lt;/h3&gt;

&lt;p&gt;How to protect mutable state, or find a good &lt;a href=&quot;https://en.wikipedia.org/wiki/Synchronization_(computer_science)&quot;&gt;&lt;em&gt;synchronization&lt;/em&gt;&lt;/a&gt; policy, totally depends on the nature of the data and the operations involved. This section is about bringing awareness of the concurrency issues you can face instead of listing all the different ways and APIs to protect mutable state. Nonetheless, here’s some tips and APIs you can start with to make your mutable variables thread-safe.&lt;/p&gt;

&lt;h4 id=&quot;encapsulation&quot;&gt;Encapsulation&lt;/h4&gt;

&lt;p&gt;Mutable state should be encapsulated and &lt;em&gt;owned&lt;/em&gt; by a class. This class centralizes access to the state, and will protect reads and writes with the synchronization policy that better fits the use case.&lt;/p&gt;

&lt;h4 id=&quot;thread-confinement&quot;&gt;Thread confinement&lt;/h4&gt;

&lt;p&gt;A solution can be to restrict read/write access to one thread. Access to the mutable state can be done in a producer/consumer way using a queue. JetBrains has &lt;a href=&quot;https://kotlinlang.org/docs/reference/coroutines/shared-mutable-state-and-concurrency.html#thread-confinement-fine-grained&quot;&gt;good documentation&lt;/a&gt; about this.&lt;/p&gt;

&lt;h4 id=&quot;dont-reinvent-thewheel&quot;&gt;Don’t reinvent the wheel&lt;/h4&gt;

&lt;p&gt;In the JVM, there are thread-safe data structures you can use to protect your mutable variables. For example, for the case of a simple counter, you can use &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicInteger.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AtomicInteger&lt;/code&gt;&lt;/a&gt;. Or, to protect the map of the code snippet above, you could use a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ConcurrentHashMap&lt;/code&gt;&lt;/a&gt;. &lt;code class=&quot;highlighter-rouge&quot;&gt;ConcurrentHashMap&lt;/code&gt; is a thread-safe, synchronized collection that optimizes the throughput of reads and writes to the map.&lt;/p&gt;

&lt;p&gt;Note that thread-safe data structures don’t guard against caller ordering problems, they just make sure memory access is atomic. They help avoid using locks when the logic is not too complicated. For example, they can’t be used in the &lt;code class=&quot;highlighter-rouge&quot;&gt;transactionCache&lt;/code&gt; example shown above because the order of operations and the logic between them need thread and access protection.&lt;/p&gt;

&lt;p&gt;Also, data in these thread-safe data structures needs to be immutable or protected to prevent race conditions when modifying objects already stored in them.&lt;/p&gt;

&lt;h4 id=&quot;custom-solutions&quot;&gt;Custom solutions&lt;/h4&gt;

&lt;p&gt;If you have compound actions that need to be synchronized, &lt;a href=&quot;https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-volatile/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@Volatile&lt;/code&gt;&lt;/a&gt; variables or thread-safe data structures won’t help! And it’s possible that the built-in &lt;a href=&quot;https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-synchronized/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@Synchronized&lt;/code&gt;&lt;/a&gt; annotation is not granular enough to make your use case efficient.&lt;/p&gt;

&lt;p&gt;In those cases, you might need to create your own synchronization mechanism using concurrent utilities such as &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html&quot;&gt;latches&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Semaphore_(programming)&quot;&gt;semaphores&lt;/a&gt;, or &lt;a href=&quot;https://en.wikipedia.org/wiki/Barrier_(computer_science)&quot;&gt;barriers&lt;/a&gt;. Other times, you can unconditionally protect multi-threaded access to code using &lt;a href=&quot;https://en.wikipedia.org/wiki/Lock_(computer_science)&quot;&gt;locks&lt;/a&gt; or mutexes.&lt;/p&gt;

&lt;p&gt;A &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/index.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Mutex&lt;/code&gt;&lt;/a&gt; in Kotlin has the suspend functions &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/lock.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;lock&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/unlock.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;unlock&lt;/code&gt;&lt;/a&gt; to manually protect parts of your coroutines code. Conveniently, the extension function &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/with-lock.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Mutex.withLock&lt;/code&gt;&lt;/a&gt; makes it easier to use:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TransactionsRepository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;defaultDispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineDispatcher&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Default&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// Mutex protecting the cache mutable state&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;cacheMutex&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;transactionsCache&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mutableMapOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;()&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;suspend&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addTransaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;withContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;defaultDispatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// Mutex makes the read&amp;amp;write cache operation thread safe&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;cacheMutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;withLock&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transactionsCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;oldList&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transactionsCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
          &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;newList&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oldList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;toMutableList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;newList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;transactionsCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;transactionsCache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;listOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As a coroutine using &lt;code class=&quot;highlighter-rouge&quot;&gt;Mutex&lt;/code&gt; suspends execution until it can proceed, it’s much more efficient than a JVM lock that blocks the thread. Be careful about using JVM synchronization classes in coroutines as that can block the thread in which the coroutine is being executed and create &lt;a href=&quot;https://en.wikipedia.org/wiki/Liveness&quot;&gt;liveness&lt;/a&gt; issues.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The block of code passed to a coroutine builder ends up executing on one or multiple JVM threads. And as such, coroutines run on the JVM threading model with all its constraints. With coroutines, it’s still possible to write vulnerable wrong multi-threaded code. So, watch out for access to shared mutable state in your code!&lt;/p&gt;</content><author><name>Manuel Vivo</name></author><category term="coroutines" /><summary type="html">Learn more about how coroutines are executed in the JVM and concurrency problems.</summary></entry><entry><title type="html">Using Hilt’s ViewModelComponent</title><link href="https://manuelvivo.dev/viewmodelcomponent" rel="alternate" type="text/html" title="Using Hilt's ViewModelComponent" /><published>2021-01-21T00:00:00+00:00</published><updated>2021-01-21T00:00:00+00:00</updated><id>https://manuelvivo.dev/viewmodelcomponent</id><content type="html" xml:base="https://manuelvivo.dev/viewmodelcomponent">&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewModelComponent&lt;/code&gt; is a component in the &lt;a href=&quot;https://developer.android.com/training/dependency-injection/hilt-android#component-hierarchy&quot;&gt;Hilt’s component hierarchy&lt;/a&gt; that follows the lifecycle of a ViewModel and allows scoping types to it.&lt;/p&gt;

&lt;p&gt;Before the &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewModelComponent&lt;/code&gt; was added to Hilt, ViewModel classes were created and injected by the &lt;code class=&quot;highlighter-rouge&quot;&gt;ActivityRetainedComponent&lt;/code&gt;. Therefore, dependencies of ViewModels could only use unscoped types or types scoped to either the &lt;code class=&quot;highlighter-rouge&quot;&gt;SingletonComponent&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;ActivityRetainedComponent&lt;/code&gt; whose instance is shared by all ViewModels.&lt;/p&gt;

&lt;p&gt;The above might not seem like a problem if each screen of your app is an Activity, as scoping a type to &lt;code class=&quot;highlighter-rouge&quot;&gt;ActivityRetainedComponent&lt;/code&gt; would mean each ViewModel class would receive a different instance of that type. However, having an activity per screen is not the case for most apps.&lt;/p&gt;

&lt;p&gt;Furthermore, the &lt;code class=&quot;highlighter-rouge&quot;&gt;SavedStateHandle&lt;/code&gt; type was not available as a default binding in &lt;code class=&quot;highlighter-rouge&quot;&gt;ActivityRetainedComponent&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now, ViewModels are created and injected by the &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewModelComponent&lt;/code&gt; that follows the lifecycle of a ViewModel. Each ViewModel instance has a different instance of &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewModelComponent&lt;/code&gt;, and to scope a type to it, use the &lt;code class=&quot;highlighter-rouge&quot;&gt;@ViewModelScoped&lt;/code&gt; annotation.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img width=&quot;600&quot; src=&quot;assets/images/2021-01-21-viewmodelcomponent_1.png&quot; /&gt;
  &lt;small&gt;Position of the ViewModelComponent in a simplified Hilt's component hierarchy&lt;/small&gt;
&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewModelComponent&lt;/code&gt; extends from &lt;code class=&quot;highlighter-rouge&quot;&gt;ActivityRetainedComponent&lt;/code&gt;. Therefore, types scoped to &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewModelComponent&lt;/code&gt; can depend on types scoped to the &lt;code class=&quot;highlighter-rouge&quot;&gt;ActivityRetainedComponent&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;SingletonComponent&lt;/code&gt;. In addition to this, the &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewModelComponent&lt;/code&gt; contains a default binding of the &lt;a href=&quot;https://developer.android.com/reference/androidx/lifecycle/SavedStateHandle&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SavedStateHandle&lt;/code&gt;&lt;/a&gt; associated with its ViewModel.&lt;/p&gt;

&lt;h2 id=&quot;scoping-to-the-viewmodelcomponent&quot;&gt;Scoping to the ViewModelComponent&lt;/h2&gt;

&lt;p&gt;Scoping to the &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewModelComponent&lt;/code&gt;, and therefore to a ViewModel, using &lt;code class=&quot;highlighter-rouge&quot;&gt;@ViewModelScoped&lt;/code&gt; gives you more flexibility and granularity than what’s possible with other components. ViewModels survive configuration changes and its lifecycle can be controlled by an activity, fragment, or even a &lt;a href=&quot;https://developer.android.com/reference/androidx/navigation/NavBackStackEntry&quot;&gt;navigation graph&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;Still, scoping to &lt;code class=&quot;highlighter-rouge&quot;&gt;ActivityComponent&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;FragmentComponent&lt;/code&gt; is useful since these components don’t survive configuration changes which might be necessary in some scenarios. Also, the &lt;code class=&quot;highlighter-rouge&quot;&gt;FragmentComponent&lt;/code&gt; extends the &lt;code class=&quot;highlighter-rouge&quot;&gt;ActivityComponent&lt;/code&gt;, behavior that you cannot have with multiple &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewModelComponent&lt;/code&gt;s.&lt;/p&gt;

&lt;p&gt;Therefore:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;To make all ViewModels share the same instance of a type, annotate it with &lt;code class=&quot;highlighter-rouge&quot;&gt;@ActivityRetainedScoped&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;To scope a type to a ViewModel, make it survive configuration changes, and/or be controlled by a navigation graph, annotate it with &lt;code class=&quot;highlighter-rouge&quot;&gt;@ViewModelScoped&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;To scope a type to the Activity and don’t make it survive configuration changes, annotate with &lt;code class=&quot;highlighter-rouge&quot;&gt;@ActivityScoped&lt;/code&gt;, or &lt;code class=&quot;highlighter-rouge&quot;&gt;@FragmentScoped&lt;/code&gt; if you want that behavior but scoping to a fragment.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;using-viewmodelscoped&quot;&gt;Using @ViewModelScoped&lt;/h2&gt;

&lt;p&gt;This annotation allows you to scope a type to an instance of a ViewModel. The same instance will be injected in all the dependencies that the ViewModel and its dependencies have.&lt;/p&gt;

&lt;p&gt;In the following example, &lt;code class=&quot;highlighter-rouge&quot;&gt;LoginViewModel&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;RegistrationViewModel&lt;/code&gt; make use of a &lt;code class=&quot;highlighter-rouge&quot;&gt;@ViewModelScoped&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;UserInputAuthData&lt;/code&gt; type that contains mutable state.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@ViewModelScoped&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Scopes type to the ViewModel&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UserInputAuthData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SavedStateHandle&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Default binding in ViewModelComponent&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* Cached data and logic here */&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RegistrationViewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;userInputAuthData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UserInputAuthData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;validateUsernameUseCase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ValidateUsernameUseCase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;validatePasswordUseCase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ValidatePasswordUseCase&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ViewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LoginViewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;userInputAuthData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UserInputAuthData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;validateUsernameUseCase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ValidateUsernameUseCase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;validatePasswordUseCase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ValidatePasswordUseCase&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ViewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ValidateUsernameUseCase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;userInputAuthData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UserInputAuthData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;repository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UserRepository&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ValidatePasswordUseCase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;userInputAuthData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UserInputAuthData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;repository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UserRepository&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Since &lt;code class=&quot;highlighter-rouge&quot;&gt;UserInputAuthData&lt;/code&gt; is scoped to the ViewModel, &lt;code class=&quot;highlighter-rouge&quot;&gt;RegistrationViewModel&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;LoginViewModel&lt;/code&gt; will receive a &lt;em&gt;different instance&lt;/em&gt; of &lt;code class=&quot;highlighter-rouge&quot;&gt;UserInputAuthData&lt;/code&gt;. However, the unscoped UseCase dependencies of each ViewModel use the &lt;em&gt;same instance&lt;/em&gt; that its ViewModel uses.&lt;/p&gt;

&lt;h2 id=&quot;adding-bindings-to-the-viewmodelcomponent&quot;&gt;Adding bindings to the ViewModelComponent&lt;/h2&gt;

&lt;p&gt;You can add bindings to the &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewModelComponent&lt;/code&gt; as with any other component. If in the code snippet above, &lt;code class=&quot;highlighter-rouge&quot;&gt;ValidateUsernameUseCase&lt;/code&gt; was an interface, you could tell Hilt the implementation to use as follows:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Module&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@InstallIn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ViewModelComponent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UserAuthModule&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;nd&quot;&gt;@Provides&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;provideValidateUsernameUseCase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;userInputAuthData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UserInputAuthData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// scoped to ViewModelComponent&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;repository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UserRepository&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ValidateUsernameUseCase&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ValidateUsernameUseCaseImpl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;userInputAuthData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;repository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewModelComponent&lt;/code&gt; follows the lifecycle of a ViewModel and allows scoping types to it. As ViewModel’s lifecycle can be controlled by an activity, fragment, or even a &lt;a href=&quot;https://developer.android.com/reference/androidx/navigation/NavBackStackEntry&quot;&gt;navigation graph&lt;/a&gt;, you get more flexibility and granularity in the number of places where you can scope.&lt;/p&gt;

&lt;p&gt;To scope a type to a ViewModel, annotate it with &lt;code class=&quot;highlighter-rouge&quot;&gt;@ViewModelScoped&lt;/code&gt;. To make all ViewModels share the same instance of a type, annotate it with &lt;code class=&quot;highlighter-rouge&quot;&gt;@ActivityRetainedScoped&lt;/code&gt;.&lt;/p&gt;</content><author><name>Manuel Vivo</name></author><category term="hilt" /><summary type="html">ViewModelComponent is a component in the Hilt’s component hierarchy that follows the lifecycle of a ViewModel and allows scoping types to it.</summary></entry><entry><title type="html">Simplifying APIs with coroutines and Flow</title><link href="https://manuelvivo.dev/simplifying-apis-coroutines" rel="alternate" type="text/html" title="Simplifying APIs with coroutines and Flow" /><published>2020-12-16T00:00:00+00:00</published><updated>2020-12-16T00:00:00+00:00</updated><id>https://manuelvivo.dev/simplifying-apis-coroutines</id><content type="html" xml:base="https://manuelvivo.dev/simplifying-apis-coroutines">&lt;p&gt;Learn how to create your own coroutine adapters and see how they work under the hood&lt;/p&gt;

&lt;p&gt;If you’re a library author, you might want to make your Java-based or callback-based libraries easier to consume from Kotlin using coroutines and Flow. Alternatively, if you’re an API consumer, you may be willing to adapt a 3rd party API surface to coroutines to make them more Kotlin friendly.&lt;/p&gt;

&lt;p&gt;This article covers how to simplify APIs using coroutines and Flow as well as how to build your own adapter using &lt;code class=&quot;highlighter-rouge&quot;&gt;suspendCancellableCoroutine&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;callbackFlow&lt;/code&gt; APIs. For the most curious ones, those APIs will be dissected and you’ll see how they work under the hood.&lt;/p&gt;

&lt;p&gt;If you prefer to watch a video about this topic, check this one out:&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/OmHePYcHbyQ&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;h2 id=&quot;check-existing-coroutine-adapters&quot;&gt;Check existing coroutine adapters&lt;/h2&gt;

&lt;p&gt;Before writing your own wrappers for existing APIs, check if an adapter or &lt;a href=&quot;https://medium.com/androiddevelopers/extend-your-code-readability-with-kotlin-extensions-542bf702aa36&quot;&gt;extension function&lt;/a&gt; is available for your use case. There are existing libraries with coroutine adapters for common types.&lt;/p&gt;

&lt;h3 id=&quot;future-types&quot;&gt;Future types&lt;/h3&gt;

&lt;p&gt;For future types, there are integrations for Java 8’s &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/integration/kotlinx-coroutines-jdk8/src/future/Future.kt&quot;&gt;CompletableFuture&lt;/a&gt;, and Guava’s &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/integration/kotlinx-coroutines-guava/src/ListenableFuture.kt&quot;&gt;ListenableFuture&lt;/a&gt;. This is not an exhaustive list, search online if an adapter for your future type already exists.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Awaits completion of CompletionStage without blocking a thread&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;suspend&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;CompletionStage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt; 

&lt;span class=&quot;c1&quot;&gt;// Awaits completion of ListenableFuture without blocking a thread&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;suspend&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ListenableFuture&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;With these functions, you can get rid of callbacks and just suspend the coroutine until the future result comes back.&lt;/p&gt;

&lt;h3 id=&quot;reactive-streams&quot;&gt;Reactive Streams&lt;/h3&gt;

&lt;p&gt;For reactive stream libraries, there are integrations for &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/tree/master/reactive/kotlinx-coroutines-rx3&quot;&gt;RxJava&lt;/a&gt;, &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/tree/master/reactive/kotlinx-coroutines-jdk9&quot;&gt;Java 9 APIs&lt;/a&gt;, and &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/tree/master/reactive/kotlinx-coroutines-reactive&quot;&gt;reactive streams&lt;/a&gt; libraries.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Transforms the given reactive Publisher into Flow.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Any&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Publisher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;asFlow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Flow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;These functions convert a reactive stream into Flow.&lt;/p&gt;

&lt;h3 id=&quot;android-specific-apis&quot;&gt;Android specific APIs&lt;/h3&gt;

&lt;p&gt;For Jetpack libraries or Android platform APIs, take a look at the &lt;a href=&quot;https://developer.android.com/kotlin/ktx/extensions-list&quot;&gt;Jetpack KTX libraries list&lt;/a&gt;. Currently, more than 20 libraries have a KTX version, creating sweet idiomatic versions of Java APIs, ranging from SharedPreferences to ViewModels, SQLite and even Play Core.&lt;/p&gt;

&lt;h3 id=&quot;callbacks&quot;&gt;Callbacks&lt;/h3&gt;

&lt;p&gt;Callbacks are a very common solution for asynchronous communication. In fact, we use them for the Java programming language solution in the &lt;a href=&quot;https://developer.android.com/guide/background/threading&quot;&gt;Running tasks in background thread guide&lt;/a&gt;. However, they come with some drawbacks: this design leads to nested callbacks which ends up in incomprehensible code. Also, error handling is more complicated as there isn’t an easy way to propagate them.&lt;/p&gt;

&lt;p&gt;In Kotlin, you can simplify calling callbacks using coroutines, but for that, you’ll need to build your own adapter.&lt;/p&gt;

&lt;h2 id=&quot;build-your-own-adapter&quot;&gt;Build your own adapter&lt;/h2&gt;

&lt;p&gt;If you don’t find an adapter for your use case, it’s usually quite straightforward to write your own. &lt;strong&gt;For one-shot async calls, use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/suspend-cancellable-coroutine.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;suspendCancellableCoroutine&lt;/code&gt;&lt;/a&gt; API. For streaming data, use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/callback-flow.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;callbackFlow&lt;/code&gt;&lt;/a&gt; API&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;As an exercise, the following examples will use the &lt;a href=&quot;https://developers.google.com/android/reference/com/google/android/gms/location/FusedLocationProviderClient.html&quot;&gt;Fused Location Provider&lt;/a&gt; API from Google Play Services to get location data. The API surface is simple but it uses callbacks to perform async operations. With coroutines, we can get rid of those callbacks that can quickly make our code unreadable when the logic gets complicated.&lt;/p&gt;

&lt;p&gt;In case you want to explore other solutions, you can get inspiration from the source code of all the functions linked above.&lt;/p&gt;

&lt;h3 id=&quot;one-shot-async-calls&quot;&gt;One-shot async calls&lt;/h3&gt;

&lt;p&gt;The &lt;a href=&quot;https://developers.google.com/android/reference/com/google/android/gms/location/FusedLocationProviderClient.html&quot;&gt;Fused Location Provider&lt;/a&gt; API provides the &lt;a href=&quot;https://developers.google.com/android/reference/com/google/android/gms/location/FusedLocationProviderClient#getLastLocation()&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;getLastLocation&lt;/code&gt;&lt;/a&gt; method to obtain the &lt;a href=&quot;https://developer.android.com/training/location/retrieve-current&quot;&gt;last known location&lt;/a&gt;. The ideal API for coroutines is a suspend function that returns exactly that.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note that this API returns a &lt;a href=&quot;https://developers.google.com/android/reference/com/google/android/gms/tasks/Task&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Task&lt;/code&gt;&lt;/a&gt; and there’s already an &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/integration/kotlinx-coroutines-play-services/src/Tasks.kt&quot;&gt;adapter&lt;/a&gt; available for it. However, for learning purposes, we’ll use it as an example.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We can have a better API by creating an extension function on &lt;code class=&quot;highlighter-rouge&quot;&gt;FusedLocationProviderClient&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;suspend&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FusedLocationProviderClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;awaitLastLocation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Location&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As this is a one-shot async operation, we use the &lt;code class=&quot;highlighter-rouge&quot;&gt;suspendCancellableCoroutine&lt;/code&gt; function: a low-level building block for creating suspending functions from the coroutines library.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;suspendCancellableCoroutine&lt;/code&gt; executes the block of code passed to it as a parameter, then suspends the coroutine execution while waiting for the signal to continue. The coroutine will resume executing when the &lt;code class=&quot;highlighter-rouge&quot;&gt;resume&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;resumeWithException&lt;/code&gt; method is called in the coroutine’s &lt;a href=&quot;https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-continuation/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Continuation&lt;/code&gt;&lt;/a&gt; object. For more information about continuations, check out the &lt;em&gt;&lt;a href=&quot;https://manuelvivo.dev/suspend-modifier&quot;&gt;suspend modifier under the hood article&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;We use the callbacks that can be added to the &lt;code class=&quot;highlighter-rouge&quot;&gt;getLastLocation&lt;/code&gt; method to resume the coroutine appropriately. See the implementation below:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Extension function on FusedLocationProviderClient, returns last known location&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;suspend&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FusedLocationProviderClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;awaitLastLocation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Location&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// Create a new coroutine that can be cancelled&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;suspendCancellableCoroutine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;continuation&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Add listeners that will resume the execution of this coroutine&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;lastLocation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;addOnSuccessListener&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;location&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// Resume coroutine and return location&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;continuation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;resume&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;addOnFailureListener&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// Resume the coroutine by throwing an exception&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;continuation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;resumeWithException&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// End of the suspendCancellableCoroutine block. This suspends the&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// coroutine until one of the callbacks calls the continuation parameter.&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Note: Although you will also find a non-cancellable version of this coroutine builder in the coroutines library (i.e. &lt;a href=&quot;https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/suspend-coroutine.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;suspendCoroutine&lt;/code&gt;&lt;/a&gt;), it is preferable to always choose &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/suspend-cancellable-coroutine.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;suspendCancellableCoroutine&lt;/code&gt;&lt;/a&gt; to handle cancellation of the coroutine scope, or to propagate cancellation from the underlying API.&lt;/p&gt;

&lt;h4 id=&quot;suspendcancellablecoroutine-under-the-hood&quot;&gt;suspendCancellableCoroutine under the hood&lt;/h4&gt;

&lt;p&gt;Internally, &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/CancellableContinuation.kt#L305&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;suspendCancellableCoroutine&lt;/code&gt;&lt;/a&gt; uses &lt;a href=&quot;https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/coroutines/intrinsics/Intrinsics.kt#L41&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;suspendCoroutineUninterceptedOrReturn&lt;/code&gt;&lt;/a&gt; to get the &lt;code class=&quot;highlighter-rouge&quot;&gt;Continuation&lt;/code&gt; of the coroutine inside a suspend function. That &lt;code class=&quot;highlighter-rouge&quot;&gt;Continuation&lt;/code&gt; object is intercepted by a &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/CancellableContinuation.kt&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CancellableContinuation&lt;/code&gt;&lt;/a&gt; that will control the lifecycle of that coroutine from that point (its &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/CancellableContinuationImpl.kt&quot;&gt;implementation&lt;/a&gt; has the functionality of a &lt;code class=&quot;highlighter-rouge&quot;&gt;Job&lt;/code&gt; with some restrictions).&lt;/p&gt;

&lt;p&gt;After that, the lambda passed to &lt;code class=&quot;highlighter-rouge&quot;&gt;suspendCancellableCoroutine&lt;/code&gt; will be executed and the coroutine will either resume immediately if the lambda returns a result or will be suspended until the &lt;code class=&quot;highlighter-rouge&quot;&gt;CancellableContinuation&lt;/code&gt; is resumed manually from the lambda.&lt;/p&gt;

&lt;p&gt;See my own comments in the following code snippet (following the &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/CancellableContinuation.kt#L305&quot;&gt;original implementation&lt;/a&gt;) to understand what’s happening:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;suspend&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;suspendCancellableCoroutine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;crossinline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;CancellableContinuation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Unit&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Get the Continuation object of the coroutine that it's running this suspend function&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;suspendCoroutineUninterceptedOrReturn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uCont&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Take over the control of the coroutine. The Continuation's been&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// intercepted and it follows the CancellableContinuationImpl lifecycle now&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;cancellable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CancellableContinuationImpl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uCont&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;intercepted&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt;
 
    &lt;span class=&quot;c1&quot;&gt;// Call block of code with the cancellable continuation&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancellable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        
    &lt;span class=&quot;c1&quot;&gt;// Either suspend the coroutine and wait for the Continuation to be resumed&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// manually in `block` or return a result if `block` has finished executing&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cancellable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To know more about how suspend functions work under the hood, check out the &lt;em&gt;&lt;a href=&quot;https://manuelvivo.dev/suspend-modifier&quot;&gt;suspend modifier under the hood article&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&quot;streaming-data&quot;&gt;Streaming data&lt;/h3&gt;

&lt;p&gt;If instead we wanted to receive periodic location updates (using the &lt;a href=&quot;https://developers.google.com/android/reference/com/google/android/gms/location/FusedLocationProviderClient#requestLocationUpdates(com.google.android.gms.location.LocationRequest,%20com.google.android.gms.location.LocationCallback,%20android.os.Looper)&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;requestLocationUpdates&lt;/code&gt;&lt;/a&gt; function) whenever the user’s device moves in the real world, we’d need to create a stream of data using &lt;a href=&quot;https://kotlinlang.org/docs/reference/coroutines/flow.html&quot;&gt;Flow&lt;/a&gt;. The ideal API would look like this:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FusedLocationProviderClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;locationFlow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Flow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To convert streaming callback-based APIs to Flow, use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/callback-flow.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;callbackFlow&lt;/code&gt;&lt;/a&gt; flow builder that creates a new flow. In the &lt;code class=&quot;highlighter-rouge&quot;&gt;callbackFlow&lt;/code&gt; lambda, we’re in the context of a coroutine, therefore, suspend functions can be called. Unlike the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;flow&lt;/code&gt;&lt;/a&gt; flow builder, &lt;code class=&quot;highlighter-rouge&quot;&gt;channelFlow&lt;/code&gt; allows values to be emitted from a different &lt;code class=&quot;highlighter-rouge&quot;&gt;CoroutineContext&lt;/code&gt; or outside a coroutine, with the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-send-channel/offer.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;offer&lt;/code&gt;&lt;/a&gt; method.&lt;/p&gt;

&lt;p&gt;Normally, flow adapters using &lt;code class=&quot;highlighter-rouge&quot;&gt;callbackFlow&lt;/code&gt; follow these three generic steps:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Create the callback that adds elements into the flow using &lt;code class=&quot;highlighter-rouge&quot;&gt;offer&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Register the callback.&lt;/li&gt;
  &lt;li&gt;Wait for the consumer to cancel the coroutine and unregister the callback.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Applying this recipe to this use case, we get the following implementation:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Send location updates to the consumer &lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FusedLocationProviderClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;locationFlow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;callbackFlow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// A new Flow is created. This code executes in a coroutine!&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 1. Create callback and add elements into the flow&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;callback&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;: &lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;LocationCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onLocationResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LocationResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Ignore null responses&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;location&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;locations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;nf&quot;&gt;offer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Send location to the flow&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Throwable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;c1&quot;&gt;// Location couldn't be sent to the flow &lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 2. Register the callback to get location updates by calling requestLocationUpdates&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;requestLocationUpdates&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;createLocationRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Looper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getMainLooper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;addOnFailureListener&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// in case of error, close the Flow&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 3. Wait for the consumer to cancel the coroutine and unregister&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// the callback. This suspends the coroutine until the Flow is closed.&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;awaitClose&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Clean up code goes here&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;removeLocationUpdates&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;callbackflow-under-the-hood&quot;&gt;callbackFlow under the hood&lt;/h4&gt;

&lt;p&gt;Internally, &lt;code class=&quot;highlighter-rouge&quot;&gt;callbackFlow&lt;/code&gt; uses a &lt;a href=&quot;https://kotlinlang.org/docs/reference/coroutines/channels.html&quot;&gt;channel&lt;/a&gt;, which is conceptually very similar to a blocking &lt;a href=&quot;https://en.wikipedia.org/wiki/Queue_(abstract_data_type)&quot;&gt;queue&lt;/a&gt;. A channel is configured with a &lt;code class=&quot;highlighter-rouge&quot;&gt;capacity&lt;/code&gt;: the number of elements that can be buffered. The channel created in &lt;code class=&quot;highlighter-rouge&quot;&gt;callbackFlow&lt;/code&gt; has the default capacity of 64 elements. When adding a new element to an already full channel, &lt;code class=&quot;highlighter-rouge&quot;&gt;send&lt;/code&gt; will suspend the producer until there’s space for the new element in the channel whereas &lt;code class=&quot;highlighter-rouge&quot;&gt;offer&lt;/code&gt; won’t add the element to the channel and will return &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt; immediately.&lt;/p&gt;

&lt;h4 id=&quot;awaitclose-under-the-hood&quot;&gt;awaitClose under the hood&lt;/h4&gt;

&lt;p&gt;Interestingly, &lt;code class=&quot;highlighter-rouge&quot;&gt;awaitClose&lt;/code&gt; uses &lt;code class=&quot;highlighter-rouge&quot;&gt;suspendCancellableCoroutine&lt;/code&gt; under the hood. See my own comments in the following code snippet (following the &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/channels/Produce.kt#L49&quot;&gt;original implementation&lt;/a&gt;) to understand what’s happening:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;suspend&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ProducerScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;*&amp;gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;awaitClose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Unit&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{})&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Suspend the coroutine with a cancellable continuation&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;suspendCancellableCoroutine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cont&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// Suspend forever and resume the coroutine successfully only &lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// when the Flow/Channel is closed&lt;/span&gt;
      &lt;span class=&quot;nf&quot;&gt;invokeOnClose&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cont&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;resume&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Always execute caller's clean up code&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;reusing-the-flow&quot;&gt;Reusing the Flow&lt;/h4&gt;

&lt;p&gt;Flows are cold and lazy unless specified otherwise with intermediate operators such as &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/conflate.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;conflate&lt;/code&gt;&lt;/a&gt;. This means that the builder block will be executed each time a terminal operator is called on the flow. This might not be a huge problem in our case as adding new location listeners is cheap, however, it might make a difference in other implementations.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;FusedLocationProviderClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;locationFlow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;callbackFlow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;shareIn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Make the flow follow the applicationScope&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;applicationScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Emit the last emitted element to new collectors&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;replay&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Keep the producer active while there are active subscribers&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;started&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SharingStarted&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;WhileSubscribed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To learn more about best practices for adding an &lt;code class=&quot;highlighter-rouge&quot;&gt;applicationScope&lt;/code&gt; to your app, check out this &lt;a href=&quot;https://manuelvivo.dev/coroutines-cancellation-exceptions-4&quot;&gt;article&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Consider creating coroutine adapters to make your APIs or existing APIs concise, readable and Kotlin idiomatic. First check if the adapter is already available and if not, create your own using &lt;code class=&quot;highlighter-rouge&quot;&gt;suspendCancellableCoroutine&lt;/code&gt; for one-shot calls and &lt;code class=&quot;highlighter-rouge&quot;&gt;callbackFlow&lt;/code&gt; for streaming data.&lt;/p&gt;

&lt;p&gt;To get hands-on this topic, check out the &lt;a href=&quot;https://codelabs.developers.google.com/codelabs/building-kotlin-extensions-library&quot;&gt;&lt;em&gt;Building a Kotlin extensions library&lt;/em&gt; codelab&lt;/a&gt;.&lt;/p&gt;</content><author><name>Manuel Vivo</name></author><category term="coroutines" /><summary type="html">Learn how to create your own coroutine adapters and see how they work under the hood</summary></entry><entry><title type="html">Migrating from Dagger to Hilt — Is it worth it?</title><link href="https://manuelvivo.dev/migrating-to-Hilt" rel="alternate" type="text/html" title="Migrating from Dagger to Hilt — Is it worth it?" /><published>2020-11-24T00:00:01+00:00</published><updated>2020-11-24T00:00:01+00:00</updated><id>https://manuelvivo.dev/migrating-to-Hilt</id><content type="html" xml:base="https://manuelvivo.dev/migrating-to-Hilt">&lt;p&gt;Consider whether or not you should migrate your Dagger app to Hilt&lt;/p&gt;

&lt;p&gt;Hilt got released in June 2020 as a way to standardize dependency injection (DI) in Android. For new projects, Hilt provides compile time correctness, runtime performance and scalability (read more about that &lt;a href=&quot;https://manuelvivo.dev/di-with-hilt&quot;&gt;here&lt;/a&gt;)! However, what are the benefits for an application that already uses Dagger? &lt;strong&gt;Should you be migrating&lt;/strong&gt; your current app to Hilt? The following are some reasons whether your team should invest migrating from Dagger to Hilt.&lt;/p&gt;

&lt;h2 id=&quot;-androidx-extensions&quot;&gt;✅ AndroidX extensions&lt;/h2&gt;

&lt;p&gt;If you already have Dagger working with ViewModels or WorkManager, you saw that wiring up your ViewModelFactory and WorkerFactory requires quite a lot of boilerplate code and Dagger knowledge. The most common implementation uses &lt;a href=&quot;https://dagger.dev/dev-guide/multibindings.html&quot;&gt;multibindings&lt;/a&gt; which is one of the most complex features in Dagger that developers often struggle to understand. Hilt makes working with AndroidX a lot easier by removing that boilerplate code. What’s even better is that you don’t even need to inject the Factory in the Android framework class, you call it as if Hilt wasn’t there. With &lt;code class=&quot;highlighter-rouge&quot;&gt;@ViewModelInject&lt;/code&gt;, Hilt generates the right &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewModelProvider.Factory&lt;/code&gt; for you that &lt;code class=&quot;highlighter-rouge&quot;&gt;@AndroidEntryPoint&lt;/code&gt; activities and fragments can use directly.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;PlayViewModel&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@ViewModelInject&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MusicDatabase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ViewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@AndroidEntryPoint&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;PlayActivity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppCompatActivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;viewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;PlayViewModel&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;viewModels&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Bundle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bundle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;viewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;play&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;-testing-apis&quot;&gt;✅ Testing APIs&lt;/h2&gt;

&lt;p&gt;DI is supposed to make testing easier but ironically, having Dagger working in tests requires &lt;a href=&quot;https://developer.android.com/training/dependency-injection/dagger-android#dagger-testing&quot;&gt;a lot of work&lt;/a&gt;. The fact that you have to maintain both the prod and test Dagger graph at the same time makes it notably worse than &lt;a href=&quot;https://developer.android.com/training/dependency-injection/hilt-testing&quot;&gt;Hilt’s approach&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Hilt tests can explicitly modify the DI graph using the &lt;a href=&quot;https://developer.android.com/training/dependency-injection/hilt-testing#replace-binding&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@UninstallModules&lt;/code&gt;&lt;/a&gt; functionality. Apart from that, you get other perks like &lt;a href=&quot;https://developer.android.com/training/dependency-injection/hilt-testing#binding-new&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@BindValue&lt;/code&gt;&lt;/a&gt; that allows you to easily bind fields of your tests into the DI graph.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@UninstallModules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;AnalyticsModule&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@HiltAndroidTest&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ExampleTest&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  
  &lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Rule&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;hiltRule&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HiltAndroidRule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  
  &lt;span class=&quot;nd&quot;&gt;@BindValue&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@JvmField&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;analyticsRepository&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FakeAnalyticsRepository&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  
  &lt;span class=&quot;nd&quot;&gt;@Test&lt;/span&gt; 
  &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;myTest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;-consistency&quot;&gt;✅ Consistency&lt;/h2&gt;

&lt;p&gt;There are multiple ways to have the same functionality working in Dagger. The historical lack of guidance for Android apps (that we &lt;a href=&quot;https://developer.android.com/training/dependency-injection/dagger-basics&quot;&gt;tackled&lt;/a&gt; last year) has caused multiple debates in the community and ultimately created inconsistencies in the way developers use and set up Dagger in their Android apps.&lt;/p&gt;

&lt;p&gt;You might argue that your current Dagger setup is really good and you perfectly know how everything works and how everything is getting injected. Therefore, migrating to Hilt is not worth it! That might be true in your case, but is it the same for the rest of the team (and potentially future colleagues)? Will you know how everything works when switching to a new project? Understanding the setup and usage of Dagger in an app can be challenging and time consuming.&lt;/p&gt;

&lt;p&gt;That time can be dramatically reduced by using Hilt into your app as the same setup is used by all Hilt applications. A new developer joining your team won’t be surprised about your Hilt setup because it’ll be pretty much the same as what they’re used to.&lt;/p&gt;

&lt;h2 id=&quot;-custom-components&quot;&gt;✅ Custom Components&lt;/h2&gt;

&lt;p&gt;Apart from the defined standard components, Hilt also gives you a way to create custom components and add them to the hierarchy which you can read more about &lt;a href=&quot;https://manuelvivo.dev/hilt-adding-components&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Even though custom components reduce consistency, you still get a lot of benefits! The module auto-discoverability (i.e. the &lt;a href=&quot;https://developer.android.com/training/dependency-injection/hilt-android#hilt-modules&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@InstallIn&lt;/code&gt;&lt;/a&gt; annotation functionality) feature as well as the test replacement features also work with custom components.&lt;/p&gt;

&lt;p&gt;However, the difference between custom components and the Hilt built-in components is that you lose the ability to automatically inject those components into Android framework classes (i.e. what &lt;code class=&quot;highlighter-rouge&quot;&gt;@AndroidEntryPoint&lt;/code&gt; does).&lt;/p&gt;

&lt;h2 id=&quot;-dagger-and-hilt-interop&quot;&gt;✅ Dagger and Hilt interop&lt;/h2&gt;

&lt;p&gt;Hilt and Dagger can co-exist together! You can benefit from Hilt in certain parts of your app while keeping the other most niche parts using Dagger if you allow Hilt to take over your &lt;code class=&quot;highlighter-rouge&quot;&gt;SingletonComponent&lt;/code&gt;. This also means that the &lt;a href=&quot;https://codelabs.developers.google.com/codelabs/android-dagger-to-hilt#0&quot;&gt;migration to Hilt can be done gradually&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;-component-dependencies&quot;&gt;❌ Component dependencies&lt;/h2&gt;

&lt;p&gt;Hilt being opinionated means it makes decisions for you. Hilt uses subcomponents for the component relationships, ready why &lt;a href=&quot;https://dagger.dev/hilt/monolithic&quot;&gt;here&lt;/a&gt;. If you’re a strong believer that your app is better off using component dependencies, Hilt is not the right tool for your app.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Migrating from Dagger to Hilt is worth it in most projects. The benefits Hilt brings to your application outnumbers the efforts of having to update. But you are not on your own! We provided lots of resources to help you out in this journey:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Comprehensive migration &lt;a href=&quot;https://dagger.dev/hilt/migration-guide&quot;&gt;documentation&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Migrating from Dagger to Hilt &lt;a href=&quot;https://codelabs.developers.google.com/codelabs/android-dagger-to-hilt#0&quot;&gt;codelab&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Migrating the Google I/O app to Hilt &lt;a href=&quot;https://medium.com/androiddevelopers/migrating-the-google-i-o-app-to-hilt-f3edf03affe5&quot;&gt;blog post&lt;/a&gt; and &lt;a href=&quot;https://github.com/google/iosched/commit/9c20fdd52d446e5fdb03369e50fb196c31ae16e3&quot;&gt;commit&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Hilt and Assisted Injection working together &lt;a href=&quot;https://gist.github.com/manuelvicnt/437668cda3a891d347e134b1de29aee1&quot;&gt;gist&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Leave a comment below if you have any questions or you’re missing any more information about this!&lt;/p&gt;</content><author><name>Manuel Vivo</name></author><category term="hilt" /><summary type="html">Consider whether or not you should migrate your Dagger app to Hilt</summary></entry><entry><title type="html">Going with the Flow</title><link href="https://manuelvivo.dev/going-with-the-flow" rel="alternate" type="text/html" title="Going with the Flow" /><published>2020-11-24T00:00:00+00:00</published><updated>2020-11-24T00:00:00+00:00</updated><id>https://manuelvivo.dev/going-with-the-flow</id><content type="html" xml:base="https://manuelvivo.dev/going-with-the-flow">&lt;p&gt;Introduction to coroutines Flow&lt;/p&gt;

&lt;h2 id=&quot;description&quot;&gt;Description&lt;/h2&gt;

&lt;p&gt;Suspend functions in Coroutines are meant for one-shot calls that could return a result. But, how can you create a stream of data to return multiple results over time? In this video of Kotlin Vocabulary, Manuel will give us the benefits of Kotlin Flow, and much more!&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/emk9_tVVLcc&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;h3 id=&quot;resources&quot;&gt;Resources&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://goo.gle/35PMGrh&quot;&gt;The ABC of Coroutines episode&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://d.android.com/kotlin/flow&quot;&gt;Flow documentation&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://goo.gle/2wHr94N&quot;&gt;Watch more Kotlin Vocabulary&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://goo.gle/AndroidDevs&quot;&gt;Subscribe to Android Developers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Manuel Vivo</name></author><category term="talks" /><category term="coroutines" /><summary type="html">Introduction to coroutines Flow</summary></entry><entry><title type="html">Scoping in Android and Hilt</title><link href="https://manuelvivo.dev/scoping-in-android" rel="alternate" type="text/html" title="Scoping in Android and Hilt" /><published>2020-07-21T00:00:00+00:00</published><updated>2020-07-21T00:00:00+00:00</updated><id>https://manuelvivo.dev/scoping-in-android</id><content type="html" xml:base="https://manuelvivo.dev/scoping-in-android">&lt;p&gt;Learn about scoping in Android and how that relates to scoping in Hilt&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Scoping&lt;/strong&gt; an object &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; to another object &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; means that throughout the lifecycle of &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;, it’ll always have the same instance of &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;. When it comes to dependency injection (DI), an object &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; scoped to a container means that the container will always provide the same instance of &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; until the container is destroyed.&lt;/p&gt;

&lt;p&gt;In Hilt, you can scope types to containers or components using annotations. For example, let’s say your app has a &lt;code class=&quot;highlighter-rouge&quot;&gt;UserManager&lt;/code&gt; type that handles logins and logouts. You could scope this type to the &lt;code class=&quot;highlighter-rouge&quot;&gt;ApplicationComponent&lt;/code&gt; (which is a container managed by the application’s lifecycle) using the &lt;code class=&quot;highlighter-rouge&quot;&gt;@Singleton&lt;/code&gt; annotation. The scoped types in the application component flow down the component hierarchy: in the example, the same instance of &lt;code class=&quot;highlighter-rouge&quot;&gt;UserManager&lt;/code&gt; will be provided to the rest of the &lt;a href=&quot;https://developer.android.com/training/dependency-injection/hilt-android#component-hierarchy&quot;&gt;Hilt components in the hierarchy&lt;/a&gt;. Any type in the app that depends on &lt;code class=&quot;highlighter-rouge&quot;&gt;UserManager&lt;/code&gt; will receive the same instance.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note: By default, bindings in Hilt are &lt;strong&gt;unscoped&lt;/strong&gt;. They are not part of any component and they can be accessed throughout the entire project. A different instance of that type will be provided every time it is requested. When you scope a binding to a component, it limits where that binding can be used and which dependencies the type can have.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;scoping-in-android&quot;&gt;Scoping in Android&lt;/h2&gt;

&lt;p&gt;With the above definition, you could argue that you can scope a type by using an instance variable of that type in a specific class, and that’s true! Without DI, you could do something like this:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ExampleActivity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppCompatActivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;analyticsAdapter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AnalyticsAdapter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;analyticsAdapter&lt;/code&gt; variable is scoped to &lt;code class=&quot;highlighter-rouge&quot;&gt;ExampleActivity&lt;/code&gt;’s lifecycle, which means it’ll be the same instance as long as this activity isn’t destroyed. If another class needs to access this scoped variable for some reason, they’ll get the same instance every time too. When a new instance of &lt;code class=&quot;highlighter-rouge&quot;&gt;ExampleActivity&lt;/code&gt; is created (e.g. the activity goes through a configuration change), a new instance of &lt;code class=&quot;highlighter-rouge&quot;&gt;AnalyticsAdapter&lt;/code&gt; will be created.&lt;/p&gt;

&lt;p&gt;With Hilt, the equivalent code is:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@ActivityScoped&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AnalyticsAdapter&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@Inject&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@AndroidEntryPoint&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ExampleActivity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppCompatActivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@Inject&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;lateinit&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;analyticsAdapter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AnalyticsAdapter&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Every time &lt;code class=&quot;highlighter-rouge&quot;&gt;ExampleActivity&lt;/code&gt; is created, it’ll hold a new instance of the &lt;code class=&quot;highlighter-rouge&quot;&gt;ActivityComponent&lt;/code&gt; DI container that will provide the same instance of &lt;code class=&quot;highlighter-rouge&quot;&gt;AnalyticsAdapter&lt;/code&gt; to dependencies below it in the &lt;a href=&quot;https://developer.android.com/training/dependency-injection/hilt-android#component-hierarchy&quot;&gt;component hierarchy&lt;/a&gt; until the activity is destroyed.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;assets/images/2020-07-21-scoping-in-android_1.png&quot; /&gt;
  &lt;small&gt;You get a new instance of `AnalyticsAdapter` and `MainActivity` after a configuration change&lt;/small&gt;
&lt;/p&gt;

&lt;h2 id=&quot;scoping-with-viewmodel&quot;&gt;Scoping with ViewModel&lt;/h2&gt;

&lt;p&gt;However, we might want &lt;code class=&quot;highlighter-rouge&quot;&gt;AnalyticsAdapter&lt;/code&gt; to survive configuration changes! We could say that we want to scope that instance to the activity until the user moves away from it.&lt;/p&gt;

&lt;p&gt;For that, you can use an &lt;a href=&quot;https://developer.android.com/topic/libraries/architecture/viewmodel&quot;&gt;Architecture Components ViewModel&lt;/a&gt; because it survives configuration changes.&lt;/p&gt;

&lt;p&gt;Without dependency injection, you could have this code:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AnalyticsAdapter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ExampleViewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ViewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;analyticsAdapter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AnalyticsAdapter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ExampleActivity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppCompatActivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;viewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ExampleViewModel&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;viewModels&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;analyticsAdapter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;viewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;analyticsAdapter&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And in this way, you scope the &lt;code class=&quot;highlighter-rouge&quot;&gt;AnalyticsAdapter&lt;/code&gt; to the ViewModel. As the activity has access to the ViewModel, it can always grab the same instance of &lt;code class=&quot;highlighter-rouge&quot;&gt;AnalyticsAdapter&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;With Hilt, you could achieve the same behavior by scoping &lt;code class=&quot;highlighter-rouge&quot;&gt;AnalyticsAdapter&lt;/code&gt; to the &lt;code class=&quot;highlighter-rouge&quot;&gt;ActivityRetainedComponent&lt;/code&gt; which also survives configuration changes:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@ActivityRetainedScoped&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AnalyticsAdapter&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@Inject&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@AndroidEntryPoint&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ExampleActivity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppCompatActivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@Inject&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;lateinit&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;analyticsAdapter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AnalyticsAdapter&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;assets/images/2020-07-21-scoping-in-android_2.png&quot; /&gt;
  &lt;small&gt;You get the same instance of `AnalyticsAdapter` after a configuration change using ViewModel or Hilt’s `ActivityRetainedScope` annotation&lt;/small&gt;
&lt;/p&gt;

&lt;p&gt;If you still want to keep the ViewModel because it needs to perform some view logic while complying with good DI practices, you can use Hilt to provide the ViewModel dependencies using &lt;code class=&quot;highlighter-rouge&quot;&gt;@ViewModelInject&lt;/code&gt; as specified in the &lt;a href=&quot;https://developer.android.com/training/dependency-injection/hilt-jetpack#viewmodels&quot;&gt;docs&lt;/a&gt;. This time, &lt;code class=&quot;highlighter-rouge&quot;&gt;AnalyticsAdapter&lt;/code&gt; doesn’t need to be scoped to &lt;code class=&quot;highlighter-rouge&quot;&gt;ActivityRetainedComponent&lt;/code&gt; because it is now manually scoped to the ViewModel:&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AnalyticsAdapter&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@Inject&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ExampleViewModel&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@ViewModelInject&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;analyticsAdapter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AnalyticsAdapter&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ViewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* ... */&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@AndroidEntryPoint&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ExampleActivity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppCompatActivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;viewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ExampleViewModel&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;viewModels&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;analyticsAdapter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;viewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;analyticsAdapter&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;What we’ve seen so far can be applied to all Hilt components that are managed by Android framework lifecycle classes; see the &lt;a href=&quot;https://developer.android.com/training/dependency-injection/hilt-android#component-scopes&quot;&gt;full list of scopes available here&lt;/a&gt;. Circling back to our initial example, scoping to the &lt;code class=&quot;highlighter-rouge&quot;&gt;ApplicationComponent&lt;/code&gt; is the same as having an instance of that type in the application class without using DI principles.&lt;/p&gt;

&lt;h2 id=&quot;scoping-with-hilt-vs-viewmodel&quot;&gt;Scoping with Hilt vs ViewModel&lt;/h2&gt;

&lt;p&gt;The advantage of scoping with Hilt is that scoped types are available in the Hilt component hierarchy whereas with ViewModel, you have to manually access the scoped types from the ViewModel.&lt;/p&gt;

&lt;p&gt;The advantage of scoping with ViewModel is that you can have ViewModels for any &lt;a href=&quot;https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LifecycleOwner&lt;/code&gt;&lt;/a&gt; objects in your application. For example, if you use the &lt;a href=&quot;https://developer.android.com/guide/navigation/navigation-getting-started&quot;&gt;Jetpack Navigation library&lt;/a&gt;, you can have a ViewModel attached to your &lt;a href=&quot;https://developer.android.com/reference/androidx/navigation/fragment/NavHostFragment&quot;&gt;NavGraph&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Hilt provides a limited number of scopes. You might find that you don’t have a scope for your particular use case — for example, when using nested fragments. For that case, you can fall back to scoping using ViewModel.&lt;/p&gt;

&lt;h2 id=&quot;injecting-viewmodels-with-hilt&quot;&gt;Injecting ViewModels with Hilt&lt;/h2&gt;

&lt;p&gt;As seen above, you can use &lt;code class=&quot;highlighter-rouge&quot;&gt;@ViewModelInject&lt;/code&gt; to inject dependencies into ViewModels. Under the hood, these bindings are kept in the &lt;code class=&quot;highlighter-rouge&quot;&gt;ActivityRetainedComponent&lt;/code&gt;, which is why you can only inject types that are either unscoped, or scoped to &lt;code class=&quot;highlighter-rouge&quot;&gt;ActivityRetainedComponent&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;ApplicationComponent&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The ViewModel factory generated by Hilt is available in the &lt;code class=&quot;highlighter-rouge&quot;&gt;getDefaultViewModelProviderFactory()&lt;/code&gt; method of &lt;code class=&quot;highlighter-rouge&quot;&gt;@AndroidEntryPoint&lt;/code&gt;-annotated activities and fragments. That gives you more flexibility as you can use it in &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewModelProvider&lt;/code&gt; to obtain other ViewModels, e.g. those scoped to a &lt;code class=&quot;highlighter-rouge&quot;&gt;BackStackEntry&lt;/code&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Scoping can be costly because the provided object stays in memory until the holder is destroyed. Be thoughtful about the use of scoped objects in your application. It is appropriate to scope objects with an internal state that requires the same instance to be used, objects that need synchronization, or objects that you have measured to be expensive to create.&lt;/p&gt;

&lt;p&gt;However, when you do need to scope, you can use Hilt’s scoping annotations or the Android framework directly.&lt;/p&gt;</content><author><name>Manuel Vivo</name></author><category term="hilt" /><summary type="html">Learn about scoping in Android and how that relates to scoping in Hilt</summary></entry></feed>